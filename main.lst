MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ; $Id: main.asm,v 1.6 2007/10/08 19:39:56 tgipson Exp $
                      00002 ;
                      00003 ; Das Blinkenlichten: 10F 1-Wire RGB Receiver + Indicator
                      00004 
                      00005 ; Released under the GPL.
                      00006 
                      00007 
                      00008 ; Config bits: WDT ON, MCLR as GP3, CodeProtect OFF.
                      00009 
                      00010 
                      00011 ; ----------------------
                      00012 
                      00013 #define         MYADDR          0x01            ; Personalized address to be stored in THIS chip. Each c
                            hip on the bus
                      00014                                                                         ; must have a unique address to 
                            be controlled independently...
                      00015 
                      00016 #define         COMM_ANODE      0x01            ; If indicator is common-anode, polarity of output drive
                             and idle are inverted
                      00017 
                      00018 ; ----------------------
                      00019 
                      00020         list    p=10f200
                      00021         #include "p10f200.inc"
                      00001         LIST
                      00002 ; P10F200.INC  Standard Header File, Version 1.02    Microchip Technology, Inc.
                      00125         LIST
                      00022 
                      00023 
                      00024 
0000                  00025         org 0x00                        ; effective reset vector
0000   0A40           00026         goto    start
                      00027 
                      00028         ; First 64 bytes and last byte (osc. calibration word) are readable regardless of CodeProtect bi
                            ts, so
                      00029         ; put the revision there so we always have it, even if these bits get set.
                      00030 
                      00031 ; NOTES: This eats almost 1/4 of the code space; remove or shorten if things get tight.
                      00032 ; 'DT' stores in a (1 byte -> 1 word) readable format; probably decodes as RETLW xx
0001                  00033 str_version:
0001   0824 0849 0864 00034         DT      "$Id: main.asm,v 1.6 2007/10/08 19:39:56 tgipson Exp $"
       083A 0820 086D 
       0861 0869 086E 
       082E 0861 0873 
       086D 082C 0876 
       0820 0831 082E 
       0836 0820 0832 
       0830 0830 0837 
       082F 0831 0830 
       082F 0830 0838 
       0820 0831 0839 
       083A 0833 0839 
       083A 0835 0836 
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       0820 0874 0867 
       0869 0870 0873 
       086F 086E 0820 
       0845 087
                      00035 
                      00036 
                      00037 
0040                  00038         org     D'64'
0040                  00039 start:
0040   0004           00040         clrwdt
0041   0C7E           00041         movlw   B'01111110'
0042   0025           00042         movwf   OSCCAL          ; disregard calibration and set osc. speed to maximum; GP2 on GP2
                      00043 
0043   0CC8           00044         movlw   B'11001000'     ; wakeup-on-change DISabled, pullups DISabled, timer0 clk internal, sour
                            ce edge low-to-high (don't care), prescaler assigned to WDT, /1
0044   0002           00045         OPTION                          ; store into OPTION reg.
                      00046 
0045   0C00           00047         movlw   B'00000000'     ; set all pins as output which can be
0046   0006           00048         TRIS    GPIO            ; ...
0047   0066           00049         clrf    GPIO
                      00050 
0048   0526           00051         bsf             GPIO, GREEN             ; briefly show startup value to show running or reset...
0049   0446           00052         bcf             GPIO, BLUE
004A   0506           00053         bsf             GPIO, RED
                      00054 
004B   0075           00055         clrf    GROUPADDR               ; initial Group 0x00 (none / same as broadcast address)
                      00056 
004C   0040           00057         clrw                                    ; Initially clear PWM intensities
                      00058         #if (COMM_ANODE == 1)   ; ...
004D   0CFF           00059         movlw   B'11111111'             ; for common-anode, '1' (voltage) on the port extinguishes the L
                            ED.
                      00060         #endif                                  ; ...
004E   0032           00061         movwf   PWM_R                   ;
004F   0033           00062         movwf   PWM_G                   ;
0050   0034           00063         movwf   PWM_B                   ;
                      00064 
0051                  00065 debug_hang:             ; show long blue to indicate startup and/or sync lost. Change according to how l
                            ong you want to hang of course...
0051   0C80           00066         movlw   0x80
0052   0031           00067         movwf   COUNT
0053   0070           00068         clrf    SCRATCH0
0054                  00069 debug_hang_outer:
0054   0004           00070         clrwdt
0055   02F0           00071         decfsz  SCRATCH0, f
0056   0A54           00072         goto    debug_hang_outer
0057   02F1           00073         decfsz  COUNT, f
0058   0A54           00074         goto    debug_hang_outer
                      00075 
                      00076 
0059                  00077 reset_sync:                                     ; Sync with extended STOP condition
0059   0666           00078         btfsc   GPIO, SDI               ; SDI low?
005A   0A59           00079         goto    reset_sync              ; if no
                      00080 
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

005B   0004           00081         clrwdt
005C   0061           00082         clrf    TMR0                    ; begin timing stop condition
005D                  00083 reset_sync_wait1:
005D   0666           00084         btfsc   GPIO, SDI               ; line still low?
005E   0A59           00085         goto    reset_sync              ; if no
005F   06E1           00086         btfsc   TMR0, 7                 ; timer rollxxxer?
0060   0A5D           00087         goto    reset_sync_wait1; if no
                      00088 
                      00089                                                         ; else - fall through and begin running...
                      00090 
0061                  00091 main:                                           ; Where it all happens; check for START condition and (i
                            f none) advance one color's PWM.
0061   0004           00092         clrwdt                                  ; WDT time-out will reset the chip if this loop is not r
                            eturned to in a timely manner (1-wire framing error, e.g. waiting for a serial bit that never co
0062   0666           00093         btfsc   GPIO, SDI               ; start bit?
0063   0A6C           00094         goto    getcmd                  ; fake 'call' - shallow stack
0064   09E0           00095         call    pwm_r
0065   0666           00096         btfsc   GPIO, SDI               ; start bit?
0066   0A6C           00097         goto    getcmd                  ; fake 'call' - shallow stack
0067   09E8           00098         call    pwm_g
0068   0666           00099         btfsc   GPIO, SDI               ; start bit?
0069   0A6C           00100         goto    getcmd                  ; fake 'call' - shallow stack
006A   09F0           00101         call    pwm_b
006B   0A61           00102         goto    main
                      00103 
                      00104 
                      00105 ; +17 processcmd
                      00106 ; 
                      00107 
                      00108 ; ---------------------------------------------------
                      00109 ; Check for incoming cmd byte on SDI. If cmd (start condition), receive the cmd packet to CMDBUF.
                      00110 ; ASSUMPTION: Start condition is long enough that the longest possible complete loop will still get us b
                            ack here in time to catch it.
                      00111 
006C                  00112 getcmd:
006C   0C16           00113         movlw   CMDBUF                  ; init buffer ptr
006D   0024           00114         movwf   FSR                             ;
                      00115 
006E                  00116 getstartbit:
006E   0666           00117         btfsc   GPIO, SDI               ; spinlock until start condition released
006F   0A6E           00118         goto    getstartbit             ; ...
                      00119 
0070                  00120 getbyte1:
0070   0061           00121         clrf    TMR0                            ; begin timing low half of bit
0071   0C08           00122         movlw   H'08'                           ; going to shift in this many bits
0072   0031           00123         movwf   COUNT                           ;
                      00124 
0073                  00125 getbit_firsthalf:
0073   09D6           00126         call    pwmjump                                 ; ONCE, in dead time. Helps reduce flicker durin
                            g saturated bus condition, at the expense of max. bus speed... 18 clocks including call/return
0074                  00127 getbit_firsthalf_end:
0074   0766           00128         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
0075   0A74           00129         goto    getbit_firsthalf_end; if no
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00130 
0076   0261           00131         comf    TMR0, f                         ; if yes - begin timing high half of bit
                      00132 
0077                  00133 getbit_secondhalf:
0077   0666           00134         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
0078   0A77           00135         goto    getbit_secondhalf       ; if no
                      00136 
0079   0201           00137         movf    TMR0, w                         ; get timer's value
007A   0030           00138         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
007B   0061           00139         clrf    TMR0                            ; begin timing low half of bit. We know it's longer than
                             a few clocks, plenty of time to...
007C   0370           00140         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
007D   0360           00141         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00142 
007E   02F1           00143         decfsz  COUNT,f                         ; got all bits?
007F   0A73           00144         goto    getbit_firsthalf        ; if no - wait for next
                      00145                                                                 ; else - fall through and begin 2nd byte
                             of cmd...
                      00146 
0080   0061           00147         clrf    TMR0                            ; begin timing low half of bit
0081   02A4           00148         incf    FSR,f
                      00149 
0082                  00150 getbyte2:
0082   0C08           00151         movlw   H'08'                           ; going to shift in this many bits
0083   0031           00152         movwf   COUNT                           ;
                      00153 
0084                  00154 getbit_firsthalf2:
0084   09D6           00155         call    pwmjump                                 ; ONCE, in dead time. xxx clocks, including call
                            ; +xxx after bit received
0085                  00156 getbit_firsthalf_end2:
0085   0766           00157         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
0086   0A85           00158         goto    getbit_firsthalf_end2; if no
                      00159 
0087   0261           00160         comf    TMR0, f                         ; if yes - begin timing high half of bit
                      00161 
0088                  00162 getbit_secondhalf2:
0088   0666           00163         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
0089   0A88           00164         goto    getbit_secondhalf2      ; if no
                      00165 
008A   0201           00166         movf    TMR0, w                         ; get timer's value
008B   0030           00167         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
008C   0061           00168         clrf    TMR0                            ; begin timing low half of bit
008D   0370           00169         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
008E   0360           00170         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00171 
008F   02F1           00172         decfsz  COUNT,f                         ; got all bits?
0090   0A84           00173         goto    getbit_firsthalf2       ; if no - wait for next
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00174 
                      00175         ; 66 clocks from here to main (18+48)
                      00176 
                      00177         ; check address to see if it's anything we respond to...
                      00178 
0091   00E4           00179         decf    FSR, f                  ; point back to 1st byte of received cmd (the address)
                      00180 
0092   0C00           00181         movlw   H'00'                   ; General Call addr? (everybody! everybody!)
0093   0180           00182         xorwf   INDF, w                 ;
0094   0643           00183         btfsc   STATUS, Z               ;
0095   0A9F           00184         goto    processcmd              ; if yes
                      00185                                                         ; else
                      00186 
0096   0C01           00187         movlw   MYADDR                  ; This chip's addr? (NOTE: Hard-coded literal from above)
0097   0180           00188         xorwf   INDF, W                 ;
0098   0643           00189         btfsc   STATUS, Z               ;
0099   0A9F           00190         goto    processcmd              ; if yes
                      00191                                                         ; else
                      00192 
009A   0215           00193         movf    GROUPADDR, w    ; This chip's Group addr? (NOTE: RAM variable)
009B   0180           00194         xorwf   INDF, W                 ;
009C   0643           00195         btfsc   STATUS, Z               ;
009D   0A9F           00196         goto    processcmd              ; if yes
                      00197 
009E   0A61           00198         goto    main                    ; else - not for us...
                      00199 
009F                  00200 processcmd:     ; 48 incl. call/return
                      00201 
009F   0C17           00202         movlw   CMDBUF+1                ; point to 2nd byte of CMDBUF (cmd)
00A0   0024           00203         movwf   FSR                             ; ...
                      00204 
00A1   06E0           00205         btfsc   INDF, 7                 ; Extended Command bit?
00A2   0AAA           00206         goto    extcmd                  ; if yes
                      00207                                                         ; else
                      00208 
00A3   06C0           00209         btfsc   INDF, 6                 ; R cmd
00A4   09B6           00210         call    processcmd_r    ; 13
00A5   06A0           00211         btfsc   INDF, 5                 ; G cmd
00A6   09BA           00212         call    processcmd_g
00A7   0680           00213         btfsc   INDF, 4                 ; B cmd
00A8   09BE           00214         call    processcmd_b
00A9   0A61           00215         goto    main                    ; done
                      00216 
                      00217 
                      00218 
                      00219 ; If payload byte was '1xxxxxxx', decode as an Extended command...
                      00220 ; 11xxxxxx Set Group Address
                      00221 ; 10000000 Enter Power Save (not implemented)
                      00222 ; 10100000 Identify (not implemented)
                      00223 
00AA                  00224 extcmd:
                      00225 
00AA   0200           00226         movf    INDF, w                 ; Decode against "Set Group"
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00AB   0EC0           00227         andlw   B'11000000'             ; only highest 2 bits specify the cmd
00AC   0030           00228         movwf   SCRATCH0                ;
                      00229 
00AD   0CC0           00230         movlw   B'11000000'
00AE   0190           00231         xorwf   SCRATCH0, w
00AF   0643           00232         btfsc   STATUS, Z
00B0   0AB2           00233         goto    setgroup
                      00234 
                      00235         ; ... other extended commands here ...
                      00236 
00B1   0A61           00237         goto    main
                      00238 
                      00239 
                      00240 
00B2                  00241 setgroup:
00B2   0200           00242         movf    INDF, w
00B3   0E3F           00243         andlw   B'00111111'             ; Max. group addr 0x40 because 2 bits were taken up by extcmd
00B4   0035           00244         movwf   GROUPADDR               ; store remaining bits as group address
00B5   0A61           00245         goto    main                    ; done
                      00246 
                      00247 
                      00248 
                      00249 
                      00250 
                      00251 
                      00252 ; ---------------------------------------------------
                      00253 ; Process command byte in buffer for the given color
                      00254 
00B6                  00255 processcmd_r:
00B6   09C2           00256         call    setpwm                          ; 7
                      00257         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00B7   0FFF           00258         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00259         #endif
00B8   0032           00260         movwf   PWM_R
00B9   0800           00261         retlw   0
00BA                  00262 processcmd_g:
00BA   09C2           00263         call    setpwm
                      00264         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00BB   0FFF           00265         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00266         #endif
00BC   0033           00267         movwf   PWM_G
00BD   0800           00268         retlw   0
00BE                  00269 processcmd_b:
00BE   09C2           00270         call    setpwm
                      00271         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00BF   0FFF           00272         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00273         #endif
00C0   0034           00274         movwf   PWM_B
00C1   0800           00275         retlw   0
                      00276 
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00277 
                      00278 ; ---------------------------------------------------
                      00279 ; Given low 4 bits of cmd in INDF, return that many '1's in WREG.
                      00280 ;
                      00281 ; Want to return a value containing the number of '1's specified in the intensity
                      00282 ; value. But want to spread them out for faster switching and less perceivable flicker.
00C2                  00283 setpwm:
00C2   0200           00284         movf    INDF, w         ; cmd value
00C3   0E0F           00285         andlw   B'00001111'     ; mask off bogus bits
00C4   01E2           00286         addwf   PCL, f          ; skip that many instructions
00C5   0800           00287         retlw   B'00000000' ; 0x00
00C6   0801           00288         retlw   B'00000001' ; 0x01
00C7   0811           00289         retlw   B'00010001' ; 0x02
00C8   0849           00290         retlw   B'01001001' ; 0x03
00C9   0855           00291         retlw   B'01010101' ; 0x04
00CA   0857           00292         retlw   B'01010111' ; 0x05
00CB   0877           00293         retlw   B'01110111' ; 0x06
00CC   087F           00294         retlw   B'01111111' ; 0x07
00CD   08FF           00295         retlw   B'11111111' ; 0x08      ; last valid value
00CE   08FF           00296         retlw   B'11111111' ; 0x09      ; Should not be sent any values this high; we can't represent th
                            em in the PWM registers anyway
00CF   08FF           00297         retlw   B'11111111' ; 0x0A
00D0   08FF           00298         retlw   B'11111111' ; 0x0B
00D1   08FF           00299         retlw   B'11111111' ; 0x0C
00D2   08FF           00300         retlw   B'11111111' ; 0x0D
00D3   08FF           00301         retlw   B'11111111' ; 0x0E
00D4   08FF           00302         retlw   B'11111111' ; 0x0F
00D5   0800           00303         retlw   0x00            ; pure paranoia
                      00304 
                      00305 ; ---------------------------------------------------
                      00306 ; Perform one iteration/rotation of "poor man's PWM" for each color's register
                      00307 
                      00308 ; 'pwmjump' tries to evenly distribute PWM advances during bit receives by the value of the COUNT regist
                            er 
                      00309 ; (used during 1-wire receive to tell how many bits remaining). Well, we have 8 bits and 3 colors, so re
                            d will
                      00310 ; cycle a little slower than the rest during 1-wire receives, if anyone cares ;)
                      00311 
                      00312                                                         ; ---------------
                      00313         #if COMM_ANODE==0               ; Switched in for common-cathode drive
                      00314 pwmjump:
                      00315         movf    COUNT, w
                      00316         addwf   PCL, f
                      00317         goto    pwm_g   ; 0x00
                      00318         goto    pwm_b   ; 0x01
                      00319         goto    pwm_r   ; 0x02
                      00320         goto    pwm_g   ; 0x03
                      00321         goto    pwm_b   ; 0x04
                      00322         goto    pwm_r   ; 0x05
                      00323         goto    pwm_g   ; 0x06
                      00324         goto    pwm_b   ; 0x07
                      00325 
                      00326 pwm:
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00327 pwm_r:
                      00328         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
                      00329         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
                      00330         btfsc   STATUS, C               ; catch the bit that just fell off the left
                      00331         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00332 
                      00333         bcf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
                      00334         btfsc   STATUS, C               ; comm. cathode: '1' = 'on'. Want to err on the side of not quit
                            e 100% duty cycle vs. dimly glowing when 'off'.
                      00335         bsf             GPIO, RED               ; .
                      00336         retlw   0
                      00337 pwm_g:
                      00338         rlf             PWM_G,f
                      00339         bcf             PWM_G, 0
                      00340         btfsc   STATUS, C
                      00341         bsf             PWM_G, 0
                      00342 
                      00343         bcf             GPIO, GREEN
                      00344         btfsc   STATUS, C
                      00345         bsf             GPIO, GREEN
                      00346         retlw   0
                      00347 pwm_b:
                      00348         rlf             PWM_B,f
                      00349         bcf             PWM_B, 0
                      00350         btfsc   STATUS, C
                      00351         bsf             PWM_B, 0
                      00352 
                      00353         bcf             GPIO, BLUE
                      00354         btfsc   STATUS, C
                      00355         bsf             GPIO, BLUE
                      00356         retlw   0
                      00357 
                      00358 
                      00359         #endif
                      00360                                                         ; ---------------------
                      00361         #if COMM_ANODE == 1             ; Switched in for common-anode drive
                      00362 
00D6                  00363 pwmjump:
00D6   0211           00364         movf    COUNT, w
00D7   01E2           00365         addwf   PCL, f
00D8   0AE8           00366         goto    pwm_g   ; 0x00
00D9   0AF0           00367         goto    pwm_b   ; 0x01
00DA   0AE0           00368         goto    pwm_r   ; 0x02
00DB   0AE8           00369         goto    pwm_g   ; 0x03
00DC   0AF0           00370         goto    pwm_b   ; 0x04
00DD   0AE0           00371         goto    pwm_r   ; 0x05
00DE   0AE8           00372         goto    pwm_g   ; 0x06
00DF   0AF0           00373         goto    pwm_b   ; 0x07
                      00374 
00E0                  00375 pwm:
00E0                  00376 pwm_r:
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00E0   0372           00377         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
00E1   0412           00378         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
00E2   0603           00379         btfsc   STATUS, C               ; catch the bit that just fell off the left
00E3   0512           00380         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00381 
00E4   0506           00382         bsf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
00E5   0703           00383         btfss   STATUS, C               ; ... Remember kids, comm. anode means '1' = 'off'.
00E6   0406           00384         bcf             GPIO, RED               ; .
00E7   0800           00385         retlw   0
00E8                  00386 pwm_g:
00E8   0373           00387         rlf             PWM_G,f
00E9   0413           00388         bcf             PWM_G, 0
00EA   0603           00389         btfsc   STATUS, C
00EB   0513           00390         bsf             PWM_G, 0
                      00391 
00EC   0526           00392         bsf             GPIO, GREEN
00ED   0703           00393         btfss   STATUS, C
00EE   0426           00394         bcf             GPIO, GREEN
00EF   0800           00395         retlw   0
00F0                  00396 pwm_b:
00F0   0374           00397         rlf             PWM_B,f
00F1   0414           00398         bcf             PWM_B, 0
00F2   0603           00399         btfsc   STATUS, C
00F3   0514           00400         bsf             PWM_B, 0
                      00401 
00F4   0546           00402         bsf             GPIO, BLUE
00F5   0703           00403         btfss   STATUS, C
00F6   0446           00404         bcf             GPIO, BLUE
00F7   0800           00405         retlw   0
                      00406         #endif
                      00407 
                      00408 
                      00409 ; -------------------
                      00410 
                      00411 
                      00412 ; Command packet format: <start> <addr[7..0]><cmd[7..0]><stop>
                      00413 ;________________________-------......16 data bits......______
                      00414 
                      00415 ; The bus idles low.
                      00416 
                      00417 ; Start condition: Bus goes HIGH and lasts for longer than the longest possible loop run, so that all de
                            vices are guaranteed to catch it.
                      00418 ; Data bits consist of a low period (low half) followed by a high period (high half). A 0 is denoted by 
                            making the LOW half longer than the HIGH half,
                      00419 ;   and a 1 by making the HIGH half longer. Ideally, all bits should total the same length, but since th
                            e low half sets the baud rate on a bit-per-bit basis,
                      00420 ;   this is not required. However, the low half should be a minimum 18 device clocks (18/1MHz=18uS) for 
                            most accurate timing, 
                      00421 ;   and should not exceed 255 device clocks (255uS).
                      00422 
                      00423 
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00424 ; Cmd BYTE format: ERGBIIII
                      00425 ; RGB: Which color(s) cmd applies to
                      00426 ; IIII: Set intensity (0 ~ 8)
                      00427 ; E: Extended Command flag as described below...
                      00428 
                      00429 ; --- Extended Commands ---
                      00430 ; 11xxxxxx : Set Group Addr to value xxxx
                      00431 ; 10000000 : Enter Power Save (not yet implemented)
                      00432 ; 10010000 : Identify (pull-up bus in response if own ID is called) (not yet implemented)
                      00433 
                      00434 #include "vars.inc"             ; Memory map
                      00001 ; $Id: $
                      00002 ; Memory register definitions for Blinkenlichten
                      00003 
                      00004 
                      00005         cblock  0x10
                      00006 
  00000010            00007         SCRATCH0        ; general purpose scratch register
  00000011            00008         COUNT           ; bits-in-byte countdown
                      00009 
  00000012            00010         PWM_R           ; poor-man's PWM registers: '1' bits will be rotated around in them
  00000013            00011         PWM_G           ;
  00000014            00012         PWM_B           ;
                      00013 
  00000015            00014         GROUPADDR       ; Storage byte for Group Address
                      00015 
  00000016            00016         CMDBUF          ; buffer start - must be at end of vars
  00000017            00017         CMDBUF2         ; 2nd byte of cmd
                      00018         endc
                      00435 #include "defs.inc"             ; Port and bit definitions
                      00001 ; $Id: $
                      00002 ; Port and bit definitions for Blinkenlichten
                      00003 
  00000003            00004 SDI             equ     3
  00000000            00005 RED             equ     0
  00000001            00006 GREEN   equ     1
  00000002            00007 BLUE    equ     2
                      00436 
                      00437         end
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE 11


SYMBOL TABLE
  LABEL                             VALUE 

BLUE                              00000002
C                                 00000000
CAL0                              00000001
CAL1                              00000002
CAL2                              00000003
CAL3                              00000004
CAL4                              00000005
CAL5                              00000006
CAL6                              00000007
CMDBUF                            00000016
CMDBUF2                           00000017
COMM_ANODE                        0x01
COUNT                             00000011
DC                                00000001
F                                 00000001
FOSC4                             00000000
FSR                               00000004
GP0                               00000000
GP1                               00000001
GP2                               00000002
GP3                               00000003
GPIO                              00000006
GPWUF                             00000007
GREEN                             00000001
GROUPADDR                         00000015
INDF                              00000000
MYADDR                            0x01
NOT_GPPU                          00000006
NOT_GPWU                          00000007
NOT_PD                            00000003
NOT_TO                            00000004
OSCCAL                            00000005
PCL                               00000002
PS0                               00000000
PS1                               00000001
PS2                               00000002
PSA                               00000003
PWM_B                             00000014
PWM_G                             00000013
PWM_R                             00000012
RED                               00000000
SCRATCH0                          00000010
SDI                               00000003
STATUS                            00000003
T0CS                              00000005
T0SE                              00000004
TMR0                              00000001
W                                 00000000
Z                                 00000002
_CP_OFF                           00000FFF
_CP_ON                            00000FF7
_IntRC_OSC                        00000FFF
_MCLRE_OFF                        00000FEF
MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE 12


SYMBOL TABLE
  LABEL                             VALUE 

_MCLRE_ON                         00000FFF
_WDT_OFF                          00000FFB
_WDT_ON                           00000FFF
__10F200                          00000001
debug_hang                        00000051
debug_hang_outer                  00000054
extcmd                            000000AA
getbit_firsthalf                  00000073
getbit_firsthalf2                 00000084
getbit_firsthalf_end              00000074
getbit_firsthalf_end2             00000085
getbit_secondhalf                 00000077
getbit_secondhalf2                00000088
getbyte1                          00000070
getbyte2                          00000082
getcmd                            0000006C
getstartbit                       0000006E
main                              00000061
processcmd                        0000009F
processcmd_b                      000000BE
processcmd_g                      000000BA
processcmd_r                      000000B6
pwm                               000000E0
pwm_b                             000000F0
pwm_g                             000000E8
pwm_r                             000000E0
pwmjump                           000000D6
reset_sync                        00000059
reset_sync_wait1                  0000005D
setgroup                          000000B2
setpwm                            000000C2
start                             00000040
str_version                       00000001


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXX----------
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXX--------

All other memory blocks unused.

Program Memory Words Used:   238
Program Memory Words Free:    18


MPASM  5.11                          MAIN.ASM   1-29-2008  3:29:15         PAGE 13





Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

