MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ; $Id: main.asm,v 1.8 2008/02/19 05:48:41 tgipson Exp $
                      00002 ;
                      00003 ; Das Blinkenlichten: 1-Wire RGB Receiver + Indicator, optimized for wearable applications
                      00004 ; (c) 2008 T. R. Gipson
                      00005 ; http://tim.cexx.org/?page_id=374
                      00006 ; This software and protocol (source and binaries) are free for non-commercial use. The source code may 
                            be freely redistributed
                      00007 ; either in modified or unmodified forms. In all cases the source code and this license text must be inc
                            luded.
                      00008 
                      00009 
                      00010 ; Version History:
                      00011 ; v0.x (2005) Nora Nightlight edition. Quick n dirty hack with hardcoded timer to distinguish 1/0 data b
                            its. Set Group Address is the only valid extended command. Didn't get around to touching it agai
                      00012 ; v1.0 (2007) Beloved edition, demoed at VNV Nation concert April 07. Changed from fixed-frequency to va
                            riable baudrate data encodeing/decoding; re-ordered some bits in the command packet format to ma
                      00013 ; v1.1 (2008) Proper edition; first public release. Implemented remaining Extended commands: power save 
                            mode, deferred update stuff, and device identification.
                      00014 
                      00015 ; ----------------------
                      00016 
                      00017 
                      00018 ; Config bits: WDT ON, MCLR as GP3, CodeProtect OFF.
                      00019 
                      00020 
                      00021 ; ----------------------
                      00022 
                      00023 #define         MYADDR          0x01            ; Personalized address to be stored in THIS chip. Each c
                            hip on the bus
                      00024                                                                         ; must have a unique address to 
                            be controlled independently...
                      00025 
                      00026 #define         COMM_ANODE      0x01            ; If indicator is common-anode, polarity of output drive
                             and idle are inverted
                      00027 
                      00028 ; ----------------------
                      00029 
                      00030 ; Base contents of the OPTION register. OPTION is write-only, so can't do read-modify-write in code. We'
                            ll be needing to set/clear individual bits and don't want to hardcode this multiple places.
                      00031 #define         OPTION_VALUES   B'01001000'     ; wakeup-on-change ENabled, pullups DISabled, timer0 clk
                             internal, source edge low-to-high (don't care), prescaler assigned to WDT, /1
                      00032 
                      00033         list    p=10f200
                      00034         #include "p10f200.inc"
                      00001         LIST
                      00002 ; P10F200.INC  Standard Header File, Version 1.02    Microchip Technology, Inc.
                      00125         LIST
                      00035 
                      00036 
                      00037 
0000                  00038         org 0x00                        ; effective reset vector. Real reset vector is the last byte of 
                            code memory, which should contain a RETLW xx instruction where xx is an oscillator calibration v
0000   0A0D           00039         goto    start
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00040 
                      00041         ; First 64 bytes and last byte (osc. calibration word) are readable regardless of CodeProtect bi
                            ts, so
                      00042         ; put the revision there so we always have it, even if these bits get set.
                      00043         ; Since the addition of the v1.1 cmds, the CVS string is much too long to put here, so adding a 
                            very short 'by hand' string instead.
                      00044         ; (That's OK, the CVS string doesn't accurately reflect real version, since I compulsively commi
                            t it every time I change e.g. the device ID
                      00045         ; and the file gets a red 'modified' mark...
                      00046 
0001                  00047 str_version:
0001   0876 0831 082E 00048         DT "v1.1 tgipson"
       0831 0820 0874 
       0867 0869 0870 
       0873 086F 086E 
                      00049 
000D                  00050 start:
                      00051         ; NOTE: These first few registers get reinitialized to defaults on ANY device Reset (including w
                            akeup from SLEEP),
                      00052         ; so we have to explicitly set them on any kind of startup.
                      00053 
000D   0EFE           00054         andlw   B'11111110'
000E   0025           00055         movwf   OSCCAL          ; Use factory OSCCAL value from last ROM byte; GP2 on GP2
                      00056 ;       movlw   B'01111110'
                      00057 ;       movwf   OSCCAL          ; disregard calibration and set osc. speed to maximum; GP2 on GP2
                      00058 
000F   0C48           00059         movlw   OPTION_VALUES   ; see define above
0010   0002           00060         OPTION                          ; store into OPTION reg.
                      00061 
0011   0C00           00062         movlw   B'00000000'     ; set all pins as output which can be
0012   0006           00063         TRIS    GPIO            ; ...
                      00064 
                      00065 
                      00066 
                      00067         ; Now that that's out of the way, determine how we woke up... 
                      00068         ; WDT can't be shut off in code, so we check for both pin-change wakeup and WDT-wakeup-from-SLEE
                            P.
                      00069         ; In the latter case, branch immediately back to the powersave to execute SLEEP again, in effect
                             hitting the snooze button
                      00070         
0013   06E3           00071         btfsc   STATUS, GPWUF   ; Wakeup on pin change bit set?
0014   0A34           00072         goto    awaken                  ; if yes - just re-awakening from powersave, do not clear memory
                             contents
                      00073 ;
0015   0663           00074         btfsc   STATUS, 3               ; Was power down mode set? PD\ cleared = powerdown mode
0016   0A18           00075         goto    init                    ; if we weren't poweredowned: always fully reset
0017   0A99           00076         goto    poke_reg_0_power_save; else - only remaining option is that WDT timed out while waiting 
                            for bus activity. Back to sleep...
                      00077 
0018                  00078 init:
0018   0004           00079         clrwdt                          ; Can't do this earlier; it resets power-up state bits
                      00080 
0019   0C0B           00081         movlw   B'00001011'             ; Brief initial "i'm not dead" pulse: show blue in common-anode;
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                             yellow in common-cathode
001A   0026           00082         movwf   GPIO
                      00083 
                      00084 
001B   0075           00085         clrf    GROUPADDR               ; initial Group 0x00 (none / same as broadcast address)
001C   0079           00086         clrf    DEF_VALID               ; No deferred update buffers contain valid data
                      00087 
                      00088         #if (COMM_ANODE == 0)   ; ...
                      00089         clrw                                    ; Initially clear PWM intensities
                      00090         #endif                                  ; ...
                      00091         #if (COMM_ANODE == 1)   ; ...
001D   0CFF           00092         movlw   B'11111111'             ; for common-anode, '1' (voltage) on the port extinguishes the L
                            ED.
                      00093         #endif                                  ; ...
                      00094 
001E   0032           00095         movwf   PWM_R                   ;
001F   0033           00096         movwf   PWM_G                   ;
0020   0034           00097         movwf   PWM_B                   ;
0021   0036           00098         movwf   DEF_R                   ; Just being unnecessary anal; these don't really need to be ini
                            tialized
0022   0037           00099         movwf   DEF_G                   ; as their respective DEF_VALID bit won't get set unless new dat
                            a is written to them
0023   0038           00100         movwf   DEF_B                   ; ...
                      00101 
0024                  00102 debug_hang:             ; show long blue to indicate startup and/or sync lost. Change according to how l
                            ong you want to hang of course...
0024   0C80           00103         movlw   0x80
0025   0031           00104         movwf   COUNT
0026   0070           00105         clrf    SCRATCH0
0027                  00106 debug_hang_outer:
0027   0004           00107         clrwdt
0028   02F0           00108         decfsz  SCRATCH0, f
0029   0A27           00109         goto    debug_hang_outer
002A   02F1           00110         decfsz  COUNT, f
002B   0A27           00111         goto    debug_hang_outer
                      00112 
                      00113         ; In the event of a communications glitch (i.e. framing error) we may lose track of where we are
                             in the command/data bytes coming down the wire.
                      00114         ; If this happens, we'll soon (~18ms) be reset by the WDT, which isn't cleared inside the bit-re
                            ceive loops.
                      00115         ; In this case we want to ignore the bus until the next STOP/START condition can be identified w
                            ith some certainty, so we don't start receiving
                      00116         ; in the middle of a byte and end up right back askew again. So, wait for data line to go low an
                            d stay low for one timer rollover.
                      00117         ; It's definitely the lazy way out, but it's cheap (codespace) and reliable. Unfortunately it ma
                            y take a while to resync on a very saturated bus.
                      00118 
002C                  00119 reset_sync:                                     ; Sync with extended STOP condition (bus idle)
002C   0666           00120         btfsc   GPIO, SDI               ; SDI low?
002D   0A2C           00121         goto    reset_sync              ; if no
                      00122 
002E   0004           00123         clrwdt
002F   0061           00124         clrf    TMR0                    ; begin timing stop condition
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0030                  00125 reset_sync_wait1:
0030   0666           00126         btfsc   GPIO, SDI               ; line still low?
0031   0A2C           00127         goto    reset_sync              ; if no
0032   06E1           00128         btfsc   TMR0, 7                 ; timer rollxxxer?
0033   0A30           00129         goto    reset_sync_wait1; if no
                      00130 
                      00131                                                         ; else - fall through and begin running...
0034                  00132 awaken:
0034                  00133 main:                                           ; Where it all happens; check for START condition and (i
                            f none) advance one color's PWM.
0034   0004           00134         clrwdt                                  ; WDT time-out will reset the chip if this loop is not r
                            eturned to in a timely manner (1-wire framing error, e.g. waiting for a serial bit that never co
0035   0666           00135         btfsc   GPIO, SDI               ; start bit?
0036   0A3F           00136         goto    getcmd                  ; fake 'call' - shallow stack
0037   09E5           00137         call    pwm_r
0038   0666           00138         btfsc   GPIO, SDI               ; start bit?
0039   0A3F           00139         goto    getcmd                  ; fake 'call' - shallow stack
003A   09ED           00140         call    pwm_g
003B   0666           00141         btfsc   GPIO, SDI               ; start bit?
003C   0A3F           00142         goto    getcmd                  ; fake 'call' - shallow stack
003D   09F5           00143         call    pwm_b
003E   0A34           00144         goto    main
                      00145 
                      00146 
                      00147 ; +17 processcmd
                      00148 ; 
                      00149 
                      00150 ; ---------------------------------------------------
                      00151 ; Check for incoming cmd byte on SDI. If cmd (start condition), receive the cmd packet to CMDBUF.
                      00152 ; ASSUMPTION: Start condition is long enough that the longest possible complete loop will still get us b
                            ack here in time to catch it.
                      00153 
003F                  00154 getcmd:
003F   0C1A           00155         movlw   CMDBUF                          ; init buffer ptr
0040   0024           00156         movwf   FSR                                     ;
                      00157 
0041                  00158 getstartbit:
0041   0666           00159         btfsc   GPIO, SDI                       ; spinlock until start condition released
0042   0A41           00160         goto    getstartbit                     ; ...
                      00161 
0043                  00162 getbyte1:
0043   0061           00163         clrf    TMR0                            ; begin timing low half of bit
0044   0C08           00164         movlw   H'08'                           ; going to shift in this many bits
0045   0031           00165         movwf   COUNT                           ;
                      00166 
0046                  00167 getbit_firsthalf:
0046   09DB           00168         call    pwmjump                         ; ONCE, in dead time. Helps reduce flicker during satura
                            ted bus condition, at the expense of max. bus speed... 18 clocks including call/return
0047                  00169 getbit_firsthalf_end:
0047   0766           00170         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
0048   0A47           00171         goto    getbit_firsthalf_end; if no
                      00172 
0049   0261           00173         comf    TMR0, f                         ; if yes - begin timing high half of bit
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00174 
004A                  00175 getbit_secondhalf:
004A   0666           00176         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
004B   0A4A           00177         goto    getbit_secondhalf       ; if no
                      00178 
004C   0201           00179         movf    TMR0, w                         ; get timer's value
004D   0030           00180         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
004E   0061           00181         clrf    TMR0                            ; begin timing low half of next bit. We know it's longer
                             than a few clocks, plenty of time to...
004F   0370           00182         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
0050   0360           00183         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00184 
0051   02F1           00185         decfsz  COUNT,f                         ; got all bits?
0052   0A46           00186         goto    getbit_firsthalf        ; if no - wait for next
                      00187                                                                 ; else - fall through and begin 2nd byte
                             of cmd...
                      00188 
                      00189         ;clrf   TMR0                            ; begin timing low half of bit
0053   02A4           00190         incf    FSR,f                           ; point to 2nd buffer byte
                      00191 
0054                  00192 getbyte2:
0054   0C08           00193         movlw   H'08'                           ; going to shift in this many bits
0055   0031           00194         movwf   COUNT                           ;
                      00195 
0056                  00196 getbit_firsthalf2:
0056   09DB           00197         call    pwmjump                                 ; ONCE, in dead time.  18 clocks including call/
                            return
0057                  00198 getbit_firsthalf_end2:
0057   0766           00199         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
0058   0A57           00200         goto    getbit_firsthalf_end2; if no
                      00201 
0059   0261           00202         comf    TMR0, f                         ; if yes - begin timing high half of bit
                      00203 
005A                  00204 getbit_secondhalf2:
005A   0666           00205         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
005B   0A5A           00206         goto    getbit_secondhalf2      ; if no
                      00207 
005C   0201           00208         movf    TMR0, w                         ; get timer's value
005D   0030           00209         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
005E   0061           00210         clrf    TMR0                            ; begin timing low half of next bit
005F   0370           00211         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
0060   0360           00212         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00213 
0061   02F1           00214         decfsz  COUNT,f                         ; got all bits?
0062   0A56           00215         goto    getbit_firsthalf2       ; if no - wait for next
                      00216 
                      00217         ; 66 clocks from here to main (18+48)
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00218 
                      00219         ; check address to see if it's anything we respond to...
                      00220 
0063   00E4           00221         decf    FSR, f                  ; point back to 1st byte of received cmd (the address)
                      00222 
0064   0C00           00223         movlw   H'00'                   ; General Call addr? (everybody! everybody!)
0065   0180           00224         xorwf   INDF, w                 ;
0066   0643           00225         btfsc   STATUS, Z               ;
0067   0A71           00226         goto    processcmd              ; if yes
                      00227                                                         ; else
                      00228 
0068   0C01           00229         movlw   MYADDR                  ; This chip's addr? (NOTE: Hard-coded literal from above)
0069   0180           00230         xorwf   INDF, W                 ;
006A   0643           00231         btfsc   STATUS, Z               ;
006B   0A71           00232         goto    processcmd              ; if yes
                      00233                                                         ; else
                      00234 
006C   0215           00235         movf    GROUPADDR, w    ; This chip's Group addr? (NOTE: RAM variable)
006D   0180           00236         xorwf   INDF, W                 ;
006E   0643           00237         btfsc   STATUS, Z               ;
006F   0A71           00238         goto    processcmd              ; if yes
                      00239 
0070   0A34           00240         goto    main                    ; else - not for us...
                      00241 
0071                  00242 processcmd:     ; 48 incl. call/return
                      00243 
0071   0C1B           00244         movlw   CMDBUF+1                ; point to 2nd byte of CMDBUF (cmd)
0072   0024           00245         movwf   FSR                             ; ...
                      00246 
0073   06E0           00247         btfsc   INDF, 7                 ; Extended Command bit?
0074   0A7C           00248         goto    extcmd                  ; if yes
                      00249                                                         ; else
                      00250 
0075   06C0           00251         btfsc   INDF, 6                 ; R cmd
0076   09BC           00252         call    processcmd_r    ; 13
0077   06A0           00253         btfsc   INDF, 5                 ; G cmd
0078   09C0           00254         call    processcmd_g
0079   0680           00255         btfsc   INDF, 4                 ; B cmd
007A   09C4           00256         call    processcmd_b
007B   0A34           00257         goto    main                    ; done
                      00258 
                      00259 
                      00260 
                      00261 ; If payload byte was '1xxxxxxx', decode as an Extended command...
                      00262 ; 11xxxxxx Set Group Address to xxxxxx
                      00263 ; 10XXxxxx Poke virtual reg address XX with value xxxx, where...
                      00264 ; VAddr 00: Flags [x    identify        activate_deferred       power_save]
                      00265 ; VAddr 01: Defer buf R
                      00266 ; VAddr 02: Defer buf G
                      00267 ; VAddr 03: Defer buf B
                      00268 
007C                  00269 extcmd:
007C   06C0           00270         btfsc   INDF, 6                 ; Decode against "Set Group"
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

007D   0A81           00271         goto    setgroup                ; if Set Group bit set
                      00272                                                         ; else...
007E   06A0           00273         btfsc   INDF, 5                 ; Poke reg is 2 or 3?
007F   0A85           00274         goto    poke_reg_2_3    ; if yes
0080   0A91           00275         goto    poke_reg_0_1    ; else - must be 0 or 1
                      00276 
0081                  00277 setgroup:
0081   0200           00278         movf    INDF, w
0082   0E3F           00279         andlw   B'00111111'             ; Max. group addr 0x40 because 2 bits were taken up by extcmd
0083   0035           00280         movwf   GROUPADDR               ; store remaining bits as group address
0084   0A34           00281         goto    main                    ; done
                      00282 
0085                  00283 poke_reg_2_3:   ; Handle poke regs 2,3
0085   0680           00284         btfsc   INDF,4                  ; poke reg is 3?
0086   0A8C           00285         goto    poke_reg_3              ; if yes
                      00286                                                         ; else...
0087                  00287 poke_reg_2:                                     ; Setting Green deferred update
0087   0200           00288         movf INDF, w
0088   0E0F           00289         andlw   B'00001111'             ; only valid values
0089   0037           00290         movwf   DEF_G                   ;
008A   0539           00291         bsf             DEF_VALID, GREEN; and mark it as having a valid update
008B   0A34           00292         goto    main
                      00293 
008C                  00294 poke_reg_3:                                     ; Setting Blue deferred update
008C   0200           00295         movf INDF, w
008D   0E0F           00296         andlw   B'00001111'             ; only valid values
008E   0038           00297         movwf   DEF_B                   ;
008F   0559           00298         bsf             DEF_VALID, BLUE ; and mark it as having a valid update
0090   0A34           00299         goto    main
                      00300 
0091                  00301 poke_reg_0_1                            ; Handle poke regs 0,1
0091   0680           00302         btfsc   INDF, 4                 ; poke reg is 1?
0092   0AB7           00303         goto    poke_reg_1              ; if yes
                      00304                                                         ; else...
0093                  00305 poke_reg_0:                                     ; Handling Flag bits
                      00306                                                         ; Remember each of these virtual regs is only 4 
                            bits long because that's how many were left in the CMD byte to specify its value...
                      00307         ; Reg 0 bit 3 is currently unused, so skipping it...
                      00308 
0093   0640           00309         btfsc   INDF, 2                 ; Identify?
0094   0A9E           00310         goto    poke_reg_0_identify; if yes
                      00311                                                         ; else...
0095   0620           00312         btfsc   INDF, 1                 ; Activate deferred updates?
0096   0AAB           00313         goto    poke_reg_0_activate_def; if yes
                      00314 
                      00315                                                         ; Power Save will be the last command we check f
                            or, since if one of those is coming down the pipe we shouldn't be getting further commands for a
0097   0700           00316         btfss   INDF, 0                 ; Power Save bit?
0098   0A34           00317         goto    main                    ; if no - that's all of them!
                      00318                                                         ; else, fall through...
                      00319 
0099                  00320 poke_reg_0_power_save:          ; For best results, this should be sent on addr 0 following globally set
                            ting all intensities to 0. Otherwise you aren't saving much power, and the next cmd will wake ev
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0099   0C48           00321         movlw   OPTION_VALUES   ; get initial OPTION contents (hardcoded)
009A   0D07           00322         iorlw   B'00000111'             ; We can't kill WDT entirely, but can set WDT prescaler as slow 
                            as possible
009B   0002           00323         OPTION                                  ; write new contents
009C   0206           00324         movf    GPIO, w                 ; dummy read of I/O port to set clear any existing 'changes'
009D   0003           00325         sleep                                   ; sleep...
                      00326 ;       goto    main                    ; should never be reached; PIC10s reset on wakeup
                      00327 
                      00328 
009E                  00329 poke_reg_0_identify:
009E   0C48           00330         movlw   OPTION_VALUES   ; get initial OPTION contents (hardcoded)
009F   0EBF           00331         andlw   B'10111111'             ; enable weak pullups (GP3/SDI) by clearing bit 6
00A0   0002           00332         OPTION  
00A1   0070           00333         clrf    SCRATCH0
00A2                  00334 identify_timer: ; count to a bunch...
00A2   0004           00335         clrwdt
00A3   02F0           00336         decfsz  SCRATCH0,f              ; done counting?
00A4   0AA2           00337         goto    identify_timer  ; if no
                      00338                                                         ; else...
00A5   0C48           00339         movlw   OPTION_VALUES   ; re-get initial contents
00A6   0002           00340         OPTION                                  ; set everything back to normal (disable pullups)
00A7                  00341 identify_wait:                          ; Wait until freshly dropped line returns to '0' state. Could be
                             slow to drop with sufficiently weak pulldown
00A7   0004           00342         clrwdt
00A8   0666           00343         btfsc   GPIO, SDI               ; ...or with some other device still holding it up.
00A9   0AA7           00344         goto    identify_wait   ; if line still high
00AA   0A34           00345         goto    main                    ; else
                      00346 
00AB                  00347 poke_reg_0_activate_def:        ; A longer command than most to accomplish; might want to delay followin
                            g cmds a few ms...
00AB   0C16           00348         movlw   DEF_R                   ; point INDF to *address* of DEF_R
00AC   0024           00349         movwf   FSR                             ; ...
00AD   0619           00350         btfsc   DEF_VALID, RED
00AE   09BC           00351         call    processcmd_r
00AF   02A4           00352         incf    FSR, f                  ; pointing to DEF_G
00B0   0639           00353         btfsc   DEF_VALID, GREEN
00B1   09C0           00354         call    processcmd_g
00B2   02A4           00355         incf    FSR, f                  ; pointing to DEF_B
00B3   0659           00356         btfsc   DEF_VALID, BLUE
00B4   09C4           00357         call    processcmd_b
00B5   0079           00358         clrf    DEF_VALID               ; activated all; updates are no longer new
00B6   0A34           00359         goto    main                    ; done! FIXME: Count the clocks on this...
                      00360 
                      00361 
00B7                  00362 poke_reg_1:                                     ; Setting Red deferred update
00B7   0200           00363         movf INDF, w
00B8   0E0F           00364         andlw   B'00001111'             ; only valid values
00B9   0036           00365         movwf   DEF_R                   ;
00BA   0519           00366         bsf             DEF_VALID, RED  ; and mark it as having a valid update
00BB   0A34           00367         goto    main
                      00368 
                      00369 ; ---------------------------------------------------
                      00370 ; Process command byte in buffer for the given color
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00371 
00BC                  00372 processcmd_r:
00BC   09C8           00373         call    setpwm                          ; 7
                      00374         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00BD   0FFF           00375         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00376         #endif
00BE   0032           00377         movwf   PWM_R
00BF   0800           00378         retlw   0
00C0                  00379 processcmd_g:
00C0   09C8           00380         call    setpwm
                      00381         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00C1   0FFF           00382         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00383         #endif
00C2   0033           00384         movwf   PWM_G
00C3   0800           00385         retlw   0
00C4                  00386 processcmd_b:
00C4   09C8           00387         call    setpwm
                      00388         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00C5   0FFF           00389         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00390         #endif
00C6   0034           00391         movwf   PWM_B
00C7   0800           00392         retlw   0
                      00393 
                      00394 
                      00395 ; ---------------------------------------------------
                      00396 ; Given low 4 bits of cmd in INDF, return that many '1's in WREG.
                      00397 ;
                      00398 ; Want to return a value containing the number of '1's specified in the intensity
                      00399 ; value. But want to spread them out for faster switching and less perceivable flicker.
00C8                  00400 setpwm:
00C8   0200           00401         movf    INDF, w         ; cmd value
00C9   0E0F           00402         andlw   B'00001111'     ; mask off bogus bits
00CA   01E2           00403         addwf   PCL, f          ; skip that many instructions
00CB   0800           00404         retlw   B'00000000' ; 0x00
00CC   0801           00405         retlw   B'00000001' ; 0x01
00CD   0811           00406         retlw   B'00010001' ; 0x02
00CE   0849           00407         retlw   B'01001001' ; 0x03
00CF   0855           00408         retlw   B'01010101' ; 0x04
00D0   0857           00409         retlw   B'01010111' ; 0x05
00D1   0877           00410         retlw   B'01110111' ; 0x06
00D2   087F           00411         retlw   B'01111111' ; 0x07
00D3   08FF           00412         retlw   B'11111111' ; 0x08      ; last valid value
00D4   08FF           00413         retlw   B'11111111' ; 0x09      ; Should not be sent any values this high; we can't represent th
                            em in the PWM registers anyway
00D5   08FF           00414         retlw   B'11111111' ; 0x0A
00D6   08FF           00415         retlw   B'11111111' ; 0x0B
00D7   08FF           00416         retlw   B'11111111' ; 0x0C
00D8   08FF           00417         retlw   B'11111111' ; 0x0D
00D9   08FF           00418         retlw   B'11111111' ; 0x0E
00DA   08FF           00419         retlw   B'11111111' ; 0x0F
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00420 ;       retlw   0x00            ; pure paranoia
                      00421 
                      00422 ; ---------------------------------------------------
                      00423 ; Perform one iteration/rotation of "poor man's PWM" for each color's register
                      00424 
                      00425 ; 'pwmjump' tries to evenly distribute PWM advances during bit receives by the value of the COUNT regist
                            er 
                      00426 ; (used during 1-wire receive to tell how many bits remaining). Well, we have 8 bits and 3 colors, so re
                            d will
                      00427 ; cycle a little slower than the rest during 1-wire receives, if anyone cares ;)
                      00428 
                      00429                                                         ; ---------------
                      00430         #if COMM_ANODE==0               ; Switched in for common-cathode drive
                      00431 pwmjump:
                      00432         movf    COUNT, w
                      00433         addwf   PCL, f
                      00434         goto    pwm_g   ; 0x00
                      00435         goto    pwm_b   ; 0x01
                      00436         goto    pwm_r   ; 0x02
                      00437         goto    pwm_g   ; 0x03
                      00438         goto    pwm_b   ; 0x04
                      00439         goto    pwm_r   ; 0x05
                      00440         goto    pwm_g   ; 0x06
                      00441         goto    pwm_b   ; 0x07
                      00442 
                      00443 pwm:
                      00444 pwm_r:
                      00445         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
                      00446         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
                      00447         btfsc   STATUS, C               ; catch the bit that just fell off the left
                      00448         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00449 
                      00450         bcf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
                      00451         btfsc   STATUS, C               ; comm. cathode: '1' = 'on'. Want to err on the side of not quit
                            e 100% duty cycle vs. dimly glowing when 'off'.
                      00452         bsf             GPIO, RED               ; .
                      00453         retlw   0
                      00454 pwm_g:
                      00455         rlf             PWM_G,f
                      00456         bcf             PWM_G, 0
                      00457         btfsc   STATUS, C
                      00458         bsf             PWM_G, 0
                      00459 
                      00460         bcf             GPIO, GREEN
                      00461         btfsc   STATUS, C
                      00462         bsf             GPIO, GREEN
                      00463         retlw   0
                      00464 pwm_b:
                      00465         rlf             PWM_B,f
                      00466         bcf             PWM_B, 0
                      00467         btfsc   STATUS, C
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 11


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00468         bsf             PWM_B, 0
                      00469 
                      00470         bcf             GPIO, BLUE
                      00471         btfsc   STATUS, C
                      00472         bsf             GPIO, BLUE
                      00473         retlw   0
                      00474 
                      00475 
                      00476         #endif
                      00477                                                         ; ---------------------
                      00478         #if COMM_ANODE == 1             ; Switched in for common-anode drive
                      00479 
00DB                  00480 pwmjump:
00DB   0211           00481         movf    COUNT, w
00DC   01E2           00482         addwf   PCL, f
00DD   0AED           00483         goto    pwm_g   ; 0x00
00DE   0AF5           00484         goto    pwm_b   ; 0x01
00DF   0AE5           00485         goto    pwm_r   ; 0x02
00E0   0AED           00486         goto    pwm_g   ; 0x03
00E1   0AF5           00487         goto    pwm_b   ; 0x04
00E2   0AE5           00488         goto    pwm_r   ; 0x05
00E3   0AED           00489         goto    pwm_g   ; 0x06
00E4   0AF5           00490         goto    pwm_b   ; 0x07
                      00491 
00E5                  00492 pwm:
00E5                  00493 pwm_r:
00E5   0372           00494         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
00E6   0412           00495         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
00E7   0603           00496         btfsc   STATUS, C               ; catch the bit that just fell off the left
00E8   0512           00497         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00498 
00E9   0506           00499         bsf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
00EA   0703           00500         btfss   STATUS, C               ; ... Remember kids, comm. anode means '1' = 'off'.
00EB   0406           00501         bcf             GPIO, RED               ; .
00EC   0800           00502         retlw   0
00ED                  00503 pwm_g:
00ED   0373           00504         rlf             PWM_G,f
00EE   0413           00505         bcf             PWM_G, 0
00EF   0603           00506         btfsc   STATUS, C
00F0   0513           00507         bsf             PWM_G, 0
                      00508 
00F1   0526           00509         bsf             GPIO, GREEN
00F2   0703           00510         btfss   STATUS, C
00F3   0426           00511         bcf             GPIO, GREEN
00F4   0800           00512         retlw   0
00F5                  00513 pwm_b:
00F5   0374           00514         rlf             PWM_B,f
00F6   0414           00515         bcf             PWM_B, 0
00F7   0603           00516         btfsc   STATUS, C
00F8   0514           00517         bsf             PWM_B, 0
                      00518 
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 12


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00F9   0546           00519         bsf             GPIO, BLUE
00FA   0703           00520         btfss   STATUS, C
00FB   0446           00521         bcf             GPIO, BLUE
00FC   0800           00522         retlw   0
                      00523         #endif
                      00524 
                      00525 
                      00526 ; -------------------
                      00527 
                      00528 
                      00529 ; Command packet format: <start> <addr[7..0]><cmd[7..0]><stop>
                      00530 ;________________________-------......16 data bits......______
                      00531 
                      00532 ; The bus idles low.
                      00533 
                      00534 ; Start condition: Bus goes HIGH and stays high for longer than the longest possible loop run, so that a
                            ll devices are guaranteed to catch it.
                      00535 ; Data bits consist of a low period (low half) followed by a high period (high half). A 0 is denoted by 
                            making the LOW half longer than the HIGH half,
                      00536 ;   and a 1 by making the HIGH half longer. Ideally, all bits should total the same length, but since th
                            e low half sets the baud rate on a bit-per-bit basis,
                      00537 ;   this is not required. However, the low half should be a minimum 18 device clocks (18/1MHz=18uS) for 
                            most accurate timing, 
                      00538 ;   and should not exceed 255 device clocks (255uS).
                      00539 
                      00540 
                      00541 ; Cmd BYTE format: ERGBIIII
                      00542 ; RGB: Which color(s) cmd applies to
                      00543 ; IIII: Set intensity (0 ~ 8)
                      00544 ; E: Extended Command flag. If '1', decode remaining bits as Extended Cmd as described below...
                      00545 
                      00546 ; --- Extended Commands ---
                      00547 ; 11xxxxxx : Set Group Addr to value xxxxxx
                      00548 ; 10XXxxxx : Poke "Virtual reg" XX with contents xxxx (see below), where XX is the address of a virtual 
                            4-bit reg and xxxx is the value to poke.
                      00549 
                      00550 
                      00551 ; Vreg 00: Flags [x     identify        activate_deferred       power_save]
                      00552 ; Vreg 01: Defer buf R
                      00553 ; Vreg 02: Defer buf G
                      00554 ; Vreg 03: Defer buf B
                      00555 
                      00556 ; Detailed description of the virtual registers:
                      00557 
                      00558 ; Vreg 01 ~ 03 allow a deferred update to be sent for the R, G and B channel respectively. The new inten
                            sity value(s) are stored in the 
                      00559 ; appropriate register(s), but the old intensity values continue to be displayed until an activate_defer
                            red command is executed, at which point
                      00560 ; the new intensities are displayed. This will be particularly useful for trickling new values over the 
                            bus, then sending a single activate_deferred
                      00561 ; to all devices (addr 0) to give the appearance of a simultaneous update.
                      00562 
                      00563 ; Vreg 00 is a virtual register among virtual registers: Rather than writing a value to it, you write to
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 13


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                             it setting an individual bit to
                      00564 ; perform the requested action. Once the action is performed, the bit can be considered automatically cl
                            eared.
                      00565 ;       * Unused (bit 3): Doesn't do anything.
                      00566 ;       * Identify (bit 2): On receipt of this cmd by a given device address, this device shall pull the
                             data line HIGH (internal weak pull-up)
                      00567 ;               for a period of about 512 device clocks (or whatever, plenty long enough for master devi
                            ce to see it). Normal operation is then resumed.
                      00568 ;               Note that this may disrupt other devices on the bus, who interpret the pullup signal as 
                            a new START command. If this is bothersome an
                      00569 ;               Identify command may be followed by a startless dummy command if a device responds.
                      00570 ;       * Activate_deferred (bit 1): Replaces the currently displayed intensities with the contents of t
                            he Defer (R,G,B) regs if they contain a valid update.
                      00571 ;       * Power_save (bit 0): This command will (hopefully) stop the CPU and any pulse modulation activi
                            ties and enter a low-power SLEEP mode. The device will remain in 
                      00572 ;               SLEEP mode until the next bus activity occurs, at which point it will re-awaken. Technic
                            ally it will be waking up occasionally due to WDT, but
                      00573 ;               these activity periods will be brief.
                      00574 
                      00575 ; Ok, so the protocol as shown leaves only 1 bit unused.
                      00576 ; Definitely painting ourselves into a corner, but might be able to squeak out a little more functionali
                            ty by making that topmost flags bit
                      00577 ; a 'Use Indirection' flag that changes one of the existing VADDRs to a pointer to a numbered register, 
                            or even to a full register bank.
                      00578 ; This then gives 16 possible registers for each VADDR, but packing any further functionalities onto PIC
                            10F200 would be challenging at best.
                      00579 ; Therefore, I think the above protocol definition is OK as-is, and any bigger chip will use a more robu
                            st 2-wire (clk,data) serial and its own protocol.
                      00580 
                      00581 
                      00582 #include "vars.inc"             ; Memory map
                      00001 ; $Id: vars.inc,v 1.3 2008/02/19 05:48:41 tgipson Exp $
                      00002 ; Memory register definitions for Blinkenlichten
                      00003 
                      00004 
                      00005         cblock  0x10
                      00006 
  00000010            00007         SCRATCH0        ; general purpose scratch register
  00000011            00008         COUNT           ; bits-in-byte countdown
                      00009 
  00000012            00010         PWM_R           ; poor-man's PWM registers: '1' bits will be rotated around in them
  00000013            00011         PWM_G           ;
  00000014            00012         PWM_B           ;
                      00013 
  00000015            00014         GROUPADDR       ; Storage byte for Group Address
                      00015 
  00000016            00016         DEF_R           ; Deferred Update regs
  00000017            00017         DEF_G           ;
  00000018            00018         DEF_B           ;
  00000019            00019         DEF_VALID       ; xxxxxRGB Flags indicate whether DEFx bufs contain valid update data
                      00020 
  0000001A            00021         CMDBUF          ; buffer start - must be at end of vars
  0000001B            00022         CMDBUF2         ; 2nd byte of cmd
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 14


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00023         endc
                      00583 #include "defs.inc"             ; Port and bit definitions
                      00001 ; $Id: defs.inc,v 1.2 2008/02/18 20:26:26 tgipson Exp $
                      00002 ; Port and bit definitions for Blinkenlichten
                      00003 
  00000003            00004 SDI             equ     3
  00000000            00005 RED             equ     0
  00000001            00006 GREEN   equ     1
  00000002            00007 BLUE    equ     2
                      00584 
                      00585         end
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 15


SYMBOL TABLE
  LABEL                             VALUE 

BLUE                              00000002
C                                 00000000
CAL0                              00000001
CAL1                              00000002
CAL2                              00000003
CAL3                              00000004
CAL4                              00000005
CAL5                              00000006
CAL6                              00000007
CMDBUF                            0000001A
CMDBUF2                           0000001B
COMM_ANODE                        0x01
COUNT                             00000011
DC                                00000001
DEF_B                             00000018
DEF_G                             00000017
DEF_R                             00000016
DEF_VALID                         00000019
F                                 00000001
FOSC4                             00000000
FSR                               00000004
GP0                               00000000
GP1                               00000001
GP2                               00000002
GP3                               00000003
GPIO                              00000006
GPWUF                             00000007
GREEN                             00000001
GROUPADDR                         00000015
INDF                              00000000
MYADDR                            0x01
NOT_GPPU                          00000006
NOT_GPWU                          00000007
NOT_PD                            00000003
NOT_TO                            00000004
OPTION_VALUES                     B'01001000'
OSCCAL                            00000005
PCL                               00000002
PS0                               00000000
PS1                               00000001
PS2                               00000002
PSA                               00000003
PWM_B                             00000014
PWM_G                             00000013
PWM_R                             00000012
RED                               00000000
SCRATCH0                          00000010
SDI                               00000003
STATUS                            00000003
T0CS                              00000005
T0SE                              00000004
TMR0                              00000001
W                                 00000000
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 16


SYMBOL TABLE
  LABEL                             VALUE 

Z                                 00000002
_CP_OFF                           00000FFF
_CP_ON                            00000FF7
_IntRC_OSC                        00000FFF
_MCLRE_OFF                        00000FEF
_MCLRE_ON                         00000FFF
_WDT_OFF                          00000FFB
_WDT_ON                           00000FFF
__10F200                          00000001
awaken                            00000034
debug_hang                        00000024
debug_hang_outer                  00000027
extcmd                            0000007C
getbit_firsthalf                  00000046
getbit_firsthalf2                 00000056
getbit_firsthalf_end              00000047
getbit_firsthalf_end2             00000057
getbit_secondhalf                 0000004A
getbit_secondhalf2                0000005A
getbyte1                          00000043
getbyte2                          00000054
getcmd                            0000003F
getstartbit                       00000041
identify_timer                    000000A2
identify_wait                     000000A7
init                              00000018
main                              00000034
poke_reg_0                        00000093
poke_reg_0_1                      00000091
poke_reg_0_activate_def           000000AB
poke_reg_0_identify               0000009E
poke_reg_0_power_save             00000099
poke_reg_1                        000000B7
poke_reg_2                        00000087
poke_reg_2_3                      00000085
poke_reg_3                        0000008C
processcmd                        00000071
processcmd_b                      000000C4
processcmd_g                      000000C0
processcmd_r                      000000BC
pwm                               000000E5
pwm_b                             000000F5
pwm_g                             000000ED
pwm_r                             000000E5
pwmjump                           000000DB
reset_sync                        0000002C
reset_sync_wait1                  00000030
setgroup                          00000081
setpwm                            000000C8
start                             0000000D
str_version                       00000001
MPASM  5.14                          MAIN.ASM   2-28-2008  0:38:46         PAGE 17


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXX---

All other memory blocks unused.

Program Memory Words Used:   253
Program Memory Words Free:     3


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

