MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ; $Id: main.asm,v 1.9 2008/02/28 05:43:19 tgipson Exp $
                      00002 ;
                      00003 ; Das Blinkenlichten: 1-Wire RGB Receiver + Indicator, optimized for wearable applications
                      00004 ; (c) 2005 - 2008 T. R. Gipson (Drmn4ea)
                      00005 ; http://tim.cexx.org/?page_id=374  // drmn4ea "at" Google's free webmail service
                      00006 ; This software and protocol (source and binaries) are free for non-commercial use. Commercial use is de
                            fined as selling products
                      00007 ; which contain this code. (Use in incidentally commercial settings, e.g. art installations and public p
                            erformances is not restricted.)
                      00008 ; The source code may be freely redistributed either in modified or unmodified forms. In all cases the s
                            ource code and this license 
                      00009 ; text must be included.
                      00010 
                      00011 
                      00012 ; Version History:
                      00013 ; v0.x (2005) Nora Nightlight edition. Quick n dirty hack with hardcoded timer to distinguish 1/0 data b
                            its. Set Group Address is the only valid extended command. Didn't get around to touching it agai
                      00014 ; v1.0 (2007) Beloved edition, demoed at VNV Nation concert April 07. Changed from fixed-frequency to va
                            riable baudrate data encodeing/decoding; re-ordered some bits in the command packet format to ma
                      00015 ; v1.1 (2008) Proper edition; first public release. Implemented remaining Extended commands: power save 
                            mode, deferred update stuff, and device identification.
                      00016 ; v1.2 (2008) Improved handling of IDentify cmd; now can avoid flashes during identify as non-responding
                             devices on the bus reset. Compatibility with v1.1 devices is not affected.
                      00017 
                      00018 ; ----------------------
                      00019 
                      00020 
                      00021 ; Config bits: WDT ON, MCLR as GP3, CodeProtect OFF.
                      00022 
                      00023 
                      00024 ; ----------------------
                      00025 ; User-modifiable settings
                      00026 
                      00027 #define         MYADDR          0x1a            ; Personalized address to be stored in THIS chip. Each c
                            hip on the bus
                      00028                                                                         ; must have a unique address to 
                            be controlled independently...
                      00029 
                      00030 #define         COMM_ANODE      0x01            ; If indicator is common-anode, polarity of output drive
                             and idle are inverted
                      00031 
  00000000            00032 RED             equ     0       ; Change to GPIO pin the red LED is connected to.
  00000002            00033 GREEN   equ     2       ; Change to GPIO pin the green LED is connected to.
  00000001            00034 BLUE    equ     1       ; Change to GPIO pin the blue LED is connected to.
                      00035 
                      00036 ; ----------------------
                      00037 
                      00038 
                      00039 
                      00040 ; Base contents of the OPTION register. OPTION is write-only, so can't do read-modify-write in code. We'
                            ll be needing to set/clear individual bits and don't want to hardcode this multiple places.
                      00041 #define         OPTION_VALUES   B'01001000'     ; wakeup-on-change ENabled, pullups DISabled, timer0 clk
                             internal, source edge low-to-high (don't care), prescaler assigned to WDT, /1
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00042 
                      00043         list    p=10f200
                      00044         #include "p10f200.inc"
                      00001         LIST
                      00002 ; P10F200.INC  Standard Header File, Version 1.02    Microchip Technology, Inc.
                      00125         LIST
                      00045 
                      00046 
                      00047 
0000                  00048         org 0x00                        ; effective reset vector. Real reset vector is the last byte of 
                            code memory, which should contain a RETLW xx instruction where xx is an oscillator calibration v
0000   0A0D           00049         goto    start
                      00050 
                      00051         ; First 64 bytes and last byte (osc. calibration word) are readable regardless of CodeProtect bi
                            ts, so
                      00052         ; put the revision there so we always have it, even if these bits get set.
                      00053         ; Since the addition of the v1.1 cmds, the CVS string is much too long to put here, so adding a 
                            very short 'by hand' string instead.
                      00054         ; (That's OK, the CVS string doesn't accurately reflect real version, since I compulsively commi
                            t it every time I change e.g. the device ID
                      00055         ; and the file gets a red 'modified' mark...
                      00056 
0001                  00057 str_version:
0001   0876 0831 082E 00058         DT "v1.2 tgipson"
       0832 0820 0874 
       0867 0869 0870 
       0873 086F 086E 
                      00059 
000D                  00060 start:
                      00061         ; NOTE: These first few registers get reinitialized to defaults on ANY device Reset (including w
                            akeup from SLEEP),
                      00062         ; so we have to explicitly set them on any kind of startup.
                      00063 
000D   0EFE           00064         andlw   B'11111110'
000E   0025           00065         movwf   OSCCAL          ; Use factory OSCCAL value from last ROM byte; GP2 on GP2
                      00066 ;       movlw   B'01111110'
                      00067 ;       movwf   OSCCAL          ; disregard calibration and set osc. speed to maximum; GP2 on GP2
                      00068 
000F   0C48           00069         movlw   OPTION_VALUES   ; see define above
0010   0002           00070         OPTION                          ; store into OPTION reg.
                      00071 
0011   0C00           00072         movlw   B'00000000'     ; set all pins as output which can be
0012   0006           00073         TRIS    GPIO            ; ...
                      00074 
                      00075 
                      00076 
                      00077         ; Now that that's out of the way, determine how we woke up... 
                      00078         ; WDT can't be shut off in code, so we check for both pin-change wakeup and WDT-wakeup-from-SLEE
                            P.
                      00079         ; In the latter case, branch immediately back to the powersave to execute SLEEP again, in effect
                             hitting the snooze button
                      00080         
0013   06E3           00081         btfsc   STATUS, GPWUF   ; Wakeup on pin change bit set?
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0014   0A34           00082         goto    awaken                  ; if yes - just re-awakening from powersave, do not clear memory
                             contents
                      00083 ;
0015   0663           00084         btfsc   STATUS, 3               ; Was power down mode set? PD\ cleared = powerdown mode
0016   0A18           00085         goto    init                    ; if we weren't poweredowned: always fully reset
0017   0A99           00086         goto    poke_reg_0_power_save; else - only remaining option is that WDT timed out while waiting 
                            for bus activity. Back to sleep...
                      00087 
0018                  00088 init:
0018   0004           00089         clrwdt                          ; Can't do this earlier; it resets power-up state bits
                      00090 
0019   0C0B           00091         movlw   B'00001011'             ; Brief initial "i'm not dead" pulse: show blue in common-anode;
                             yellow in common-cathode (depends on LED pinout)
001A   0026           00092         movwf   GPIO
                      00093 
                      00094 
001B   0075           00095         clrf    GROUPADDR               ; initial Group 0x00 (none / same as broadcast address)
001C   0079           00096         clrf    DEF_VALID               ; No deferred update buffers contain valid data
                      00097 
                      00098         #if (COMM_ANODE == 0)   ; ...
                      00099         clrw                                    ; Initially clear PWM intensities
                      00100         #endif                                  ; ...
                      00101         #if (COMM_ANODE == 1)   ; ...
001D   0CFF           00102         movlw   B'11111111'             ; for common-anode, '1' (voltage) on the port extinguishes the L
                            ED.
                      00103         #endif                                  ; ...
                      00104 
001E   0032           00105         movwf   PWM_R                   ;
001F   0033           00106         movwf   PWM_G                   ;
0020   0034           00107         movwf   PWM_B                   ;
0021   0036           00108         movwf   DEF_R                   ; Just being unnecessary anal; these don't really need to be ini
                            tialized
0022   0037           00109         movwf   DEF_G                   ; as their respective DEF_VALID bit won't get set unless new dat
                            a is written to them
0023   0038           00110         movwf   DEF_B                   ; ...
                      00111 
0024                  00112 debug_hang:             ; show long blue to indicate startup and/or sync lost. Change according to how l
                            ong you want to hang of course...
0024   0C80           00113         movlw   0x80
0025   0031           00114         movwf   COUNT
0026   0070           00115         clrf    SCRATCH0
0027                  00116 debug_hang_outer:
0027   0004           00117         clrwdt
0028   02F0           00118         decfsz  SCRATCH0, f
0029   0A27           00119         goto    debug_hang_outer
002A   02F1           00120         decfsz  COUNT, f
002B   0A27           00121         goto    debug_hang_outer
                      00122 
                      00123         ; In the event of a communications glitch (i.e. framing error) we may lose track of where we are
                             in the command/data bytes coming down the wire.
                      00124         ; If this happens, we'll soon (~18ms) be reset by the WDT, which isn't cleared inside the bit-re
                            ceive loops.
                      00125         ; In this case we want to ignore the bus until the next STOP/START condition can be identified w
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            ith some certainty, so we don't start receiving
                      00126         ; in the middle of a byte and end up right back askew again. So, wait for data line to go low an
                            d stay low for one timer rollover.
                      00127         ; It's definitely the lazy way out, but it's cheap (codespace) and reliable. Unfortunately it ma
                            y take a while to resync on a very saturated bus.
                      00128 
002C                  00129 reset_sync:                                     ; Sync with extended STOP condition (bus idle)
002C   0666           00130         btfsc   GPIO, SDI               ; SDI low?
002D   0A2C           00131         goto    reset_sync              ; if no
                      00132 
002E   0004           00133         clrwdt
002F   0061           00134         clrf    TMR0                    ; begin timing stop condition
0030                  00135 reset_sync_wait1:
0030   0666           00136         btfsc   GPIO, SDI               ; line still low?
0031   0A2C           00137         goto    reset_sync              ; if no
0032   06E1           00138         btfsc   TMR0, 7                 ; timer rollxxxer?
0033   0A30           00139         goto    reset_sync_wait1; if no
                      00140 
                      00141                                                         ; else - fall through and begin running...
0034                  00142 awaken:
0034                  00143 main:                                           ; Where it all happens; check for START condition and (i
                            f none) advance one color's PWM.
0034   0004           00144         clrwdt                                  ; WDT time-out will reset the chip if this loop is not r
                            eturned to in a timely manner (1-wire framing error, e.g. waiting for a serial bit that never co
0035   0666           00145         btfsc   GPIO, SDI               ; start bit?
0036   0A3F           00146         goto    getcmd                  ; fake 'call' - shallow stack
0037   09E2           00147         call    pwm_r
0038   0666           00148         btfsc   GPIO, SDI               ; start bit?
0039   0A3F           00149         goto    getcmd                  ; fake 'call' - shallow stack
003A   09EA           00150         call    pwm_g
003B   0666           00151         btfsc   GPIO, SDI               ; start bit?
003C   0A3F           00152         goto    getcmd                  ; fake 'call' - shallow stack
003D   09F2           00153         call    pwm_b
003E   0A34           00154         goto    main
                      00155 
                      00156 
                      00157 ; +17 processcmd
                      00158 ; 
                      00159 
                      00160 ; ---------------------------------------------------
                      00161 ; Check for incoming cmd byte on SDI. If cmd (start condition), receive the cmd packet to CMDBUF.
                      00162 ; ASSUMPTION: Start condition is long enough that the longest possible complete loop will still get us b
                            ack here in time to catch it.
                      00163 
003F                  00164 getcmd:
003F   0C1A           00165         movlw   CMDBUF                          ; init buffer ptr
0040   0024           00166         movwf   FSR                                     ;
                      00167 
0041                  00168 getstartbit:
0041   0666           00169         btfsc   GPIO, SDI                       ; spinlock until start condition released
0042   0A41           00170         goto    getstartbit                     ; ...
                      00171 
0043                  00172 getbyte1:
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0043   0061           00173         clrf    TMR0                            ; begin timing low half of bit
0044   0C08           00174         movlw   H'08'                           ; going to shift in this many bits
0045   0031           00175         movwf   COUNT                           ;
                      00176 
0046                  00177 getbit_firsthalf:
0046   09D8           00178         call    pwmjump                         ; ONCE, in dead time. Helps reduce flicker during satura
                            ted bus condition, at the expense of max. bus speed... 18 clocks including call/return
0047                  00179 getbit_firsthalf_end:
0047   0766           00180         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
0048   0A47           00181         goto    getbit_firsthalf_end; if no
                      00182 
0049   0261           00183         comf    TMR0, f                         ; if yes - begin timing high half of bit
                      00184 
004A                  00185 getbit_secondhalf:
004A   0666           00186         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
004B   0A4A           00187         goto    getbit_secondhalf       ; if no
                      00188 
004C   0201           00189         movf    TMR0, w                         ; get timer's value
004D   0030           00190         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
004E   0061           00191         clrf    TMR0                            ; begin timing low half of next bit. We know it's longer
                             than a few clocks, plenty of time to...
004F   0370           00192         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
0050   0360           00193         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00194 
0051   02F1           00195         decfsz  COUNT,f                         ; got all bits?
0052   0A46           00196         goto    getbit_firsthalf        ; if no - wait for next
                      00197                                                                 ; else - fall through and begin 2nd byte
                             of cmd...
                      00198 
                      00199         ;clrf   TMR0                            ; begin timing low half of bit
0053   02A4           00200         incf    FSR,f                           ; point to 2nd buffer byte
                      00201 
0054                  00202 getbyte2:
0054   0C08           00203         movlw   H'08'                           ; going to shift in this many bits
0055   0031           00204         movwf   COUNT                           ;
                      00205 
0056                  00206 getbit_firsthalf2:
0056   09D8           00207         call    pwmjump                                 ; ONCE, in dead time.  18 clocks including call/
                            return
0057                  00208 getbit_firsthalf_end2:
0057   0766           00209         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
0058   0A57           00210         goto    getbit_firsthalf_end2; if no
                      00211 
0059   0261           00212         comf    TMR0, f                         ; if yes - begin timing high half of bit
                      00213 
005A                  00214 getbit_secondhalf2:
005A   0666           00215         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
005B   0A5A           00216         goto    getbit_secondhalf2      ; if no
                      00217 
005C   0201           00218         movf    TMR0, w                         ; get timer's value
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

005D   0030           00219         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
005E   0061           00220         clrf    TMR0                            ; begin timing low half of next bit
005F   0370           00221         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
0060   0360           00222         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00223 
0061   02F1           00224         decfsz  COUNT,f                         ; got all bits?
0062   0A56           00225         goto    getbit_firsthalf2       ; if no - wait for next
                      00226 
                      00227         ; 66 clocks from here to main (18+48)
                      00228 
                      00229         ; check address to see if it's anything we respond to...
                      00230 
0063   00E4           00231         decf    FSR, f                  ; point back to 1st byte of received cmd (the address)
                      00232 
0064   0C00           00233         movlw   H'00'                   ; General Call addr? (everybody! everybody!)
0065   0180           00234         xorwf   INDF, w                 ;
0066   0643           00235         btfsc   STATUS, Z               ;
0067   0A71           00236         goto    processcmd              ; if yes
                      00237                                                         ; else
                      00238 
0068   0C1A           00239         movlw   MYADDR                  ; This chip's addr? (NOTE: Hard-coded literal from above)
0069   0180           00240         xorwf   INDF, W                 ;
006A   0643           00241         btfsc   STATUS, Z               ;
006B   0A71           00242         goto    processcmd              ; if yes
                      00243                                                         ; else
                      00244 
006C   0215           00245         movf    GROUPADDR, w    ; This chip's Group addr? (NOTE: RAM variable)
006D   0180           00246         xorwf   INDF, W                 ;
006E   0643           00247         btfsc   STATUS, Z               ;
006F   0A71           00248         goto    processcmd              ; if yes
                      00249 
0070   0A34           00250         goto    main                    ; else - not for us...
                      00251 
0071                  00252 processcmd:     ; 48 incl. call/return
                      00253 
0071   0C1B           00254         movlw   CMDBUF+1                ; point to 2nd byte of CMDBUF (cmd)
0072   0024           00255         movwf   FSR                             ; ...
                      00256 
0073   06E0           00257         btfsc   INDF, 7                 ; Extended Command bit?
0074   0A7C           00258         goto    extcmd                  ; if yes
                      00259                                                         ; else
                      00260 
0075   06C0           00261         btfsc   INDF, 6                 ; R cmd
0076   09B9           00262         call    processcmd_r    ; 13
0077   06A0           00263         btfsc   INDF, 5                 ; G cmd
0078   09BD           00264         call    processcmd_g
0079   0680           00265         btfsc   INDF, 4                 ; B cmd
007A   09C1           00266         call    processcmd_b
007B   0A34           00267         goto    main                    ; done
                      00268 
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00269 
                      00270 
                      00271 ; If payload byte was '1xxxxxxx', decode as an Extended command...
                      00272 ; 11xxxxxx Set Group Address to xxxxxx
                      00273 ; 10XXxxxx Poke virtual reg address XX with value xxxx, where...
                      00274 ; VAddr 00: Flags [x    identify        activate_deferred       power_save]
                      00275 ; VAddr 01: Defer buf R
                      00276 ; VAddr 02: Defer buf G
                      00277 ; VAddr 03: Defer buf B
                      00278 
007C                  00279 extcmd:
007C   06C0           00280         btfsc   INDF, 6                 ; Decode against "Set Group"
007D   0A81           00281         goto    setgroup                ; if Set Group bit set
                      00282                                                         ; else...
007E   06A0           00283         btfsc   INDF, 5                 ; Poke reg is 2 or 3?
007F   0A85           00284         goto    poke_reg_2_3    ; if yes
0080   0A91           00285         goto    poke_reg_0_1    ; else - must be 0 or 1
                      00286 
0081                  00287 setgroup:
0081   0200           00288         movf    INDF, w
0082   0E3F           00289         andlw   B'00111111'             ; Max. group addr 0x40 because 2 bits were taken up by extcmd
0083   0035           00290         movwf   GROUPADDR               ; store remaining bits as group address
0084   0A34           00291         goto    main                    ; done
                      00292 
0085                  00293 poke_reg_2_3:   ; Handle poke regs 2,3
0085   0680           00294         btfsc   INDF,4                  ; poke reg is 3?
0086   0A8C           00295         goto    poke_reg_3              ; if yes
                      00296                                                         ; else...
0087                  00297 poke_reg_2:                                     ; Setting Green deferred update
0087   0200           00298         movf INDF, w
0088   0E0F           00299         andlw   B'00001111'             ; only valid values
0089   0037           00300         movwf   DEF_G                   ;
008A   0559           00301         bsf             DEF_VALID, GREEN; and mark it as having a valid update
008B   0A34           00302         goto    main
                      00303 
008C                  00304 poke_reg_3:                                     ; Setting Blue deferred update
008C   0200           00305         movf INDF, w
008D   0E0F           00306         andlw   B'00001111'             ; only valid values
008E   0038           00307         movwf   DEF_B                   ;
008F   0539           00308         bsf             DEF_VALID, BLUE ; and mark it as having a valid update
0090   0A34           00309         goto    main
                      00310 
0091                  00311 poke_reg_0_1                            ; Handle poke regs 0,1
0091   0680           00312         btfsc   INDF, 4                 ; poke reg is 1?
0092   0AB4           00313         goto    poke_reg_1              ; if yes
                      00314                                                         ; else...
0093                  00315 poke_reg_0:                                     ; Handling Flag bits
                      00316                                                         ; Remember each of these virtual regs is only 4 
                            bits long because that's how many were left in the CMD byte to specify its value...
                      00317         ; Reg 0 bit 3 is currently unused, so skipping it...
                      00318 
0093   0640           00319         btfsc   INDF, 2                 ; Identify?
0094   0A9E           00320         goto    poke_reg_0_identify; if yes
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00321                                                         ; else...
0095   0620           00322         btfsc   INDF, 1                 ; Activate deferred updates?
0096   0AA8           00323         goto    poke_reg_0_activate_def; if yes
                      00324 
                      00325                                                         ; Power Save will be the last command we check f
                            or, since if one of those is coming down the pipe we shouldn't be getting further commands for a
0097   0700           00326         btfss   INDF, 0                 ; Power Save bit?
0098   0A34           00327         goto    main                    ; if no - that's all of them!
                      00328                                                         ; else, fall through...
                      00329 
0099                  00330 poke_reg_0_power_save:          ; For best results, this should be sent on addr 0 following globally set
                            ting all intensities to 0. Otherwise you aren't saving much power, and the next cmd will wake ev
0099   0C48           00331         movlw   OPTION_VALUES   ; get initial OPTION contents (hardcoded)
009A   0D07           00332         iorlw   B'00000111'             ; We can't kill WDT entirely, but can set WDT prescaler as slow 
                            as possible
009B   0002           00333         OPTION                                  ; write new contents
009C   0206           00334         movf    GPIO, w                 ; dummy read of I/O port to set clear any existing 'changes'
009D   0003           00335         sleep                                   ; sleep...
                      00336 ;       goto    main                    ; should never be reached; PIC10s reset on wakeup
                      00337 
                      00338 
009E                  00339 poke_reg_0_identify:
009E   0C48           00340         movlw   OPTION_VALUES   ; get initial OPTION contents (hardcoded)
009F   0EBF           00341         andlw   B'10111111'             ; enable weak pullups (GP3/SDI) by clearing bit 6
00A0   0002           00342         OPTION  
00A1   0070           00343         clrf    SCRATCH0
00A2                  00344 identify_timer: ; count to a bunch...
00A2   0004           00345         clrwdt
00A3   02F0           00346         decfsz  SCRATCH0,f              ; done counting?
00A4   0AA2           00347         goto    identify_timer  ; if no
                      00348                                                         ; else...
00A5   0C48           00349         movlw   OPTION_VALUES   ; re-get initial contents
00A6   0002           00350         OPTION                                  ; set everything back to normal (disable pullups)
00A7   0A34           00351         goto    main                    ; Assume no other device is tying up the bus due to duplicated a
                            ddress, etc. (or won't be for much longer)
                      00352                                                         ;   Our Id response will be interpreted as a STA
                            RT condition by everyone else on the bus, so the best way to
                      00353                                                         ;   handle this is for the master to start some 
                            no-op cmd before the line drops, extending the Id response
                      00354                                                         ;   into its START condition.
                      00355 
                      00356 
                      00357 
00A8                  00358 poke_reg_0_activate_def:        ; A longer command than most to accomplish; might want to delay followin
                            g cmds a few ms...
00A8   0C16           00359         movlw   DEF_R                   ; point INDF to *address* of DEF_R
00A9   0024           00360         movwf   FSR                             ; ...
00AA   0619           00361         btfsc   DEF_VALID, RED
00AB   09B9           00362         call    processcmd_r
00AC   02A4           00363         incf    FSR, f                  ; pointing to DEF_G
00AD   0659           00364         btfsc   DEF_VALID, GREEN
00AE   09BD           00365         call    processcmd_g
00AF   02A4           00366         incf    FSR, f                  ; pointing to DEF_B
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00B0   0639           00367         btfsc   DEF_VALID, BLUE
00B1   09C1           00368         call    processcmd_b
00B2   0079           00369         clrf    DEF_VALID               ; activated all; updates are no longer new
00B3   0A34           00370         goto    main                    ; done! FIXME: Count the clocks on this...
                      00371 
                      00372 
00B4                  00373 poke_reg_1:                                     ; Setting Red deferred update
00B4   0200           00374         movf INDF, w
00B5   0E0F           00375         andlw   B'00001111'             ; only valid values
00B6   0036           00376         movwf   DEF_R                   ;
00B7   0519           00377         bsf             DEF_VALID, RED  ; and mark it as having a valid update
00B8   0A34           00378         goto    main
                      00379 
                      00380 ; ---------------------------------------------------
                      00381 ; Process command byte in buffer for the given color
                      00382 
00B9                  00383 processcmd_r:
00B9   09C5           00384         call    setpwm                          ; 7
                      00385         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00BA   0FFF           00386         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00387         #endif
00BB   0032           00388         movwf   PWM_R
00BC   0800           00389         retlw   0
00BD                  00390 processcmd_g:
00BD   09C5           00391         call    setpwm
                      00392         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00BE   0FFF           00393         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00394         #endif
00BF   0033           00395         movwf   PWM_G
00C0   0800           00396         retlw   0
00C1                  00397 processcmd_b:
00C1   09C5           00398         call    setpwm
                      00399         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00C2   0FFF           00400         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00401         #endif
00C3   0034           00402         movwf   PWM_B
00C4   0800           00403         retlw   0
                      00404 
                      00405 
                      00406 ; ---------------------------------------------------
                      00407 ; Given low 4 bits of cmd in INDF, return that many '1's in WREG.
                      00408 ;
                      00409 ; Want to return a value containing the number of '1's specified in the intensity
                      00410 ; value. But want to spread them out for faster switching and less perceivable flicker.
00C5                  00411 setpwm:
00C5   0200           00412         movf    INDF, w         ; cmd value
00C6   0E0F           00413         andlw   B'00001111'     ; mask off bogus bits
00C7   01E2           00414         addwf   PCL, f          ; skip that many instructions
00C8   0800           00415         retlw   B'00000000' ; 0x00
00C9   0801           00416         retlw   B'00000001' ; 0x01
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00CA   0811           00417         retlw   B'00010001' ; 0x02
00CB   0849           00418         retlw   B'01001001' ; 0x03
00CC   0855           00419         retlw   B'01010101' ; 0x04
00CD   0857           00420         retlw   B'01010111' ; 0x05
00CE   0877           00421         retlw   B'01110111' ; 0x06
00CF   087F           00422         retlw   B'01111111' ; 0x07
00D0   08FF           00423         retlw   B'11111111' ; 0x08      ; last valid value
00D1   08FF           00424         retlw   B'11111111' ; 0x09      ; Should not be sent any values this high; we can't represent th
                            em in the PWM registers anyway
00D2   08FF           00425         retlw   B'11111111' ; 0x0A
00D3   08FF           00426         retlw   B'11111111' ; 0x0B
00D4   08FF           00427         retlw   B'11111111' ; 0x0C
00D5   08FF           00428         retlw   B'11111111' ; 0x0D
00D6   08FF           00429         retlw   B'11111111' ; 0x0E
00D7   08FF           00430         retlw   B'11111111' ; 0x0F
                      00431 ;       retlw   0x00            ; pure paranoia
                      00432 
                      00433 ; ---------------------------------------------------
                      00434 ; Perform one iteration/rotation of "poor man's PWM" for each color's register
                      00435 
                      00436 ; 'pwmjump' tries to evenly distribute PWM advances during bit receives by the value of the COUNT regist
                            er 
                      00437 ; (used during 1-wire receive to tell how many bits remaining). Well, we have 8 bits and 3 colors, so re
                            d will
                      00438 ; cycle a little slower than the rest during 1-wire receives, if anyone cares ;)
                      00439 
                      00440                                                         ; ---------------
                      00441         #if COMM_ANODE==0               ; Switched in for common-cathode drive
                      00442 pwmjump:
                      00443         movf    COUNT, w
                      00444         addwf   PCL, f
                      00445         goto    pwm_g   ; 0x00
                      00446         goto    pwm_b   ; 0x01
                      00447         goto    pwm_r   ; 0x02
                      00448         goto    pwm_g   ; 0x03
                      00449         goto    pwm_b   ; 0x04
                      00450         goto    pwm_r   ; 0x05
                      00451         goto    pwm_g   ; 0x06
                      00452         goto    pwm_b   ; 0x07
                      00453 
                      00454 pwm:
                      00455 pwm_r:
                      00456         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
                      00457         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
                      00458         btfsc   STATUS, C               ; catch the bit that just fell off the left
                      00459         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00460 
                      00461         bcf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
                      00462         btfsc   STATUS, C               ; comm. cathode: '1' = 'on'. Want to err on the side of not quit
                            e 100% duty cycle vs. dimly glowing when 'off'.
                      00463         bsf             GPIO, RED               ; .
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 11


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00464         retlw   0
                      00465 pwm_g:
                      00466         rlf             PWM_G,f
                      00467         bcf             PWM_G, 0
                      00468         btfsc   STATUS, C
                      00469         bsf             PWM_G, 0
                      00470 
                      00471         bcf             GPIO, GREEN
                      00472         btfsc   STATUS, C
                      00473         bsf             GPIO, GREEN
                      00474         retlw   0
                      00475 pwm_b:
                      00476         rlf             PWM_B,f
                      00477         bcf             PWM_B, 0
                      00478         btfsc   STATUS, C
                      00479         bsf             PWM_B, 0
                      00480 
                      00481         bcf             GPIO, BLUE
                      00482         btfsc   STATUS, C
                      00483         bsf             GPIO, BLUE
                      00484         retlw   0
                      00485 
                      00486 
                      00487         #endif
                      00488                                                         ; ---------------------
                      00489         #if COMM_ANODE == 1             ; Switched in for common-anode drive
                      00490 
00D8                  00491 pwmjump:
00D8   0211           00492         movf    COUNT, w
00D9   01E2           00493         addwf   PCL, f
00DA   0AEA           00494         goto    pwm_g   ; 0x00
00DB   0AF2           00495         goto    pwm_b   ; 0x01
00DC   0AE2           00496         goto    pwm_r   ; 0x02
00DD   0AEA           00497         goto    pwm_g   ; 0x03
00DE   0AF2           00498         goto    pwm_b   ; 0x04
00DF   0AE2           00499         goto    pwm_r   ; 0x05
00E0   0AEA           00500         goto    pwm_g   ; 0x06
00E1   0AF2           00501         goto    pwm_b   ; 0x07
                      00502 
00E2                  00503 pwm:
00E2                  00504 pwm_r:
00E2   0372           00505         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
00E3   0412           00506         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
00E4   0603           00507         btfsc   STATUS, C               ; catch the bit that just fell off the left
00E5   0512           00508         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00509 
00E6   0506           00510         bsf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
00E7   0703           00511         btfss   STATUS, C               ; ... Remember kids, comm. anode means '1' = 'off'.
00E8   0406           00512         bcf             GPIO, RED               ; .
00E9   0800           00513         retlw   0
00EA                  00514 pwm_g:
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 12


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00EA   0373           00515         rlf             PWM_G,f
00EB   0413           00516         bcf             PWM_G, 0
00EC   0603           00517         btfsc   STATUS, C
00ED   0513           00518         bsf             PWM_G, 0
                      00519 
00EE   0546           00520         bsf             GPIO, GREEN
00EF   0703           00521         btfss   STATUS, C
00F0   0446           00522         bcf             GPIO, GREEN
00F1   0800           00523         retlw   0
00F2                  00524 pwm_b:
00F2   0374           00525         rlf             PWM_B,f
00F3   0414           00526         bcf             PWM_B, 0
00F4   0603           00527         btfsc   STATUS, C
00F5   0514           00528         bsf             PWM_B, 0
                      00529 
00F6   0526           00530         bsf             GPIO, BLUE
00F7   0703           00531         btfss   STATUS, C
00F8   0426           00532         bcf             GPIO, BLUE
00F9   0800           00533         retlw   0
                      00534         #endif
                      00535 
                      00536 
                      00537 ; -------------------
                      00538 
                      00539 
                      00540 ; Command packet format: <start> <addr[7..0]><cmd[7..0]><stop>
                      00541 ;________________________-------......16 data bits......______
                      00542 
                      00543 ; The bus idles low.
                      00544 
                      00545 ; Start condition: Bus goes HIGH and stays high for longer than the longest possible loop run, so that a
                            ll devices are guaranteed to catch it.
                      00546 ; Data bits consist of a low period (low half) followed by a high period (high half). A 0 is denoted by 
                            making the LOW half longer than the HIGH half,
                      00547 ;   and a 1 by making the HIGH half longer. Ideally, all bits should total the same length, but since th
                            e low half sets the baud rate on a bit-per-bit basis,
                      00548 ;   this is not required. However, the low half should be a minimum 18 device clocks (18/1MHz=18uS) for 
                            most accurate timing, 
                      00549 ;   and should not exceed 255 device clocks (255uS).
                      00550 
                      00551 
                      00552 ; Cmd BYTE format: ERGBIIII
                      00553 ; RGB: Which color(s) cmd applies to
                      00554 ; IIII: Set intensity (0 ~ 8)
                      00555 ; E: Extended Command flag. If '1', decode remaining bits as Extended Cmd as described below...
                      00556 
                      00557 ; --- Extended Commands ---
                      00558 ; 11xxxxxx : Set Group Addr to value xxxxxx
                      00559 ; 10XXxxxx : Poke "Virtual reg" XX with contents xxxx (see below), where XX is the address of a virtual 
                            4-bit reg and xxxx is the value to poke.
                      00560 
                      00561 
                      00562 ; Vreg 00: Flags [x     identify        activate_deferred       power_save]
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 13


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00563 ; Vreg 01: Defer buf R
                      00564 ; Vreg 02: Defer buf G
                      00565 ; Vreg 03: Defer buf B
                      00566 
                      00567 ; Detailed description of the virtual registers:
                      00568 
                      00569 ; Vreg 01 ~ 03 allow a deferred update to be sent for the R, G and B channel respectively. The new inten
                            sity value(s) are stored in the 
                      00570 ; appropriate register(s), but the old intensity values continue to be displayed until an activate_defer
                            red command is executed, at which point
                      00571 ; the new intensities are displayed. This will be particularly useful for trickling new values over the 
                            bus, then sending a single activate_deferred
                      00572 ; to all devices (addr 0) to give the appearance of a simultaneous update.
                      00573 
                      00574 ; Vreg 00 is a virtual register among virtual registers: Rather than writing a value to it, you write to
                             it setting an individual bit to
                      00575 ; perform the requested action. Once the action is performed, the bit can be considered automatically cl
                            eared.
                      00576 ;       * Unused (bit 3): Doesn't do anything.
                      00577 ;       * Identify (bit 2): On receipt of this cmd by a given device address, this device shall pull the
                             data line HIGH (internal weak pull-up)
                      00578 ;               for a period of about 512 device clocks (or whatever, plenty long enough for master devi
                            ce to see it). Normal operation is then resumed.
                      00579 ;               Note that this may disrupt other devices on the bus, who interpret the pullup signal as 
                            a new START command. If this is bothersome an
                      00580 ;               Identify command may be followed by a startless dummy command if a device responds.
                      00581 ;       * Activate_deferred (bit 1): Replaces the currently displayed intensities with the contents of t
                            he Defer (R,G,B) regs if they contain a valid update.
                      00582 ;       * Power_save (bit 0): This command will effectively stop the CPU and any pulse modulation activi
                            ties and enter a low-power SLEEP mode. The device will remain in 
                      00583 ;               SLEEP mode until the next bus activity occurs, at which point it will re-awaken. Technic
                            ally it will be waking up occasionally due to WDT, but
                      00584 ;               these activity periods will be brief.
                      00585 
                      00586 ; Ok, so the protocol as shown leaves only 1 bit unused.
                      00587 ; Definitely painting ourselves into a corner, but might be able to squeak out a little more functionali
                            ty by making that topmost flags bit
                      00588 ; a 'Use Indirection' flag that changes one of the existing VADDRs to a pointer to a numbered register, 
                            or even to a full register bank.
                      00589 ; This then gives 16 possible registers for each VADDR, but packing any further functionalities onto PIC
                            10F200 would be challenging at best.
                      00590 ; Therefore, I think the above protocol definition is OK as-is, and any bigger chip will use a more robu
                            st 2-wire (clk,data) serial and its own protocol.
                      00591 
                      00592 
                      00593 #include "vars.inc"             ; Memory map
                      00001 ; $Id: vars.inc,v 1.3 2008/02/19 05:48:41 tgipson Exp $
                      00002 ; Memory register definitions for Blinkenlichten
                      00003 
                      00004 
                      00005         cblock  0x10
                      00006 
  00000010            00007         SCRATCH0        ; general purpose scratch register
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 14


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000011            00008         COUNT           ; bits-in-byte countdown
                      00009 
  00000012            00010         PWM_R           ; poor-man's PWM registers: '1' bits will be rotated around in them
  00000013            00011         PWM_G           ;
  00000014            00012         PWM_B           ;
                      00013 
  00000015            00014         GROUPADDR       ; Storage byte for Group Address
                      00015 
  00000016            00016         DEF_R           ; Deferred Update regs
  00000017            00017         DEF_G           ;
  00000018            00018         DEF_B           ;
  00000019            00019         DEF_VALID       ; xxxxxRGB Flags indicate whether DEFx bufs contain valid update data
                      00020 
  0000001A            00021         CMDBUF          ; buffer start - must be at end of vars
  0000001B            00022         CMDBUF2         ; 2nd byte of cmd
                      00023         endc
                      00594 #include "defs.inc"             ; Port and bit definitions
                      00001 ; $Id: defs.inc,v 1.2 2008/02/18 20:26:26 tgipson Exp $
                      00002 ; Port and bit definitions for Blinkenlichten
                      00003 
                      00004 ; NOTE: The rest of these have been moved to the beginning of main.asm with the rest of the user-modifia
                            ble settings.
                      00005 
  00000003            00006 SDI             equ     3       ; only remaining GPIO pin is used for the data line - do not modify.
                      00595 
                      00596         end
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 15


SYMBOL TABLE
  LABEL                             VALUE 

BLUE                              00000001
C                                 00000000
CAL0                              00000001
CAL1                              00000002
CAL2                              00000003
CAL3                              00000004
CAL4                              00000005
CAL5                              00000006
CAL6                              00000007
CMDBUF                            0000001A
CMDBUF2                           0000001B
COMM_ANODE                        0x01
COUNT                             00000011
DC                                00000001
DEF_B                             00000018
DEF_G                             00000017
DEF_R                             00000016
DEF_VALID                         00000019
F                                 00000001
FOSC4                             00000000
FSR                               00000004
GP0                               00000000
GP1                               00000001
GP2                               00000002
GP3                               00000003
GPIO                              00000006
GPWUF                             00000007
GREEN                             00000002
GROUPADDR                         00000015
INDF                              00000000
MYADDR                            0x1a
NOT_GPPU                          00000006
NOT_GPWU                          00000007
NOT_PD                            00000003
NOT_TO                            00000004
OPTION_VALUES                     B'01001000'
OSCCAL                            00000005
PCL                               00000002
PS0                               00000000
PS1                               00000001
PS2                               00000002
PSA                               00000003
PWM_B                             00000014
PWM_G                             00000013
PWM_R                             00000012
RED                               00000000
SCRATCH0                          00000010
SDI                               00000003
STATUS                            00000003
T0CS                              00000005
T0SE                              00000004
TMR0                              00000001
W                                 00000000
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 16


SYMBOL TABLE
  LABEL                             VALUE 

Z                                 00000002
_CP_OFF                           00000FFF
_CP_ON                            00000FF7
_IntRC_OSC                        00000FFF
_MCLRE_OFF                        00000FEF
_MCLRE_ON                         00000FFF
_WDT_OFF                          00000FFB
_WDT_ON                           00000FFF
__10F200                          00000001
awaken                            00000034
debug_hang                        00000024
debug_hang_outer                  00000027
extcmd                            0000007C
getbit_firsthalf                  00000046
getbit_firsthalf2                 00000056
getbit_firsthalf_end              00000047
getbit_firsthalf_end2             00000057
getbit_secondhalf                 0000004A
getbit_secondhalf2                0000005A
getbyte1                          00000043
getbyte2                          00000054
getcmd                            0000003F
getstartbit                       00000041
identify_timer                    000000A2
init                              00000018
main                              00000034
poke_reg_0                        00000093
poke_reg_0_1                      00000091
poke_reg_0_activate_def           000000A8
poke_reg_0_identify               0000009E
poke_reg_0_power_save             00000099
poke_reg_1                        000000B4
poke_reg_2                        00000087
poke_reg_2_3                      00000085
poke_reg_3                        0000008C
processcmd                        00000071
processcmd_b                      000000C1
processcmd_g                      000000BD
processcmd_r                      000000B9
pwm                               000000E2
pwm_b                             000000F2
pwm_g                             000000EA
pwm_r                             000000E2
pwmjump                           000000D8
reset_sync                        0000002C
reset_sync_wait1                  00000030
setgroup                          00000081
setpwm                            000000C5
start                             0000000D
str_version                       00000001
MPASM  5.14                          MAIN.ASM   5-12-2008  0:25:42         PAGE 17


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXX------

All other memory blocks unused.

Program Memory Words Used:   250
Program Memory Words Free:     6


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

