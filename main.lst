MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ; $Id: main.asm,v 1.7 2008/02/18 20:26:26 tgipson Exp $
                      00002 ;
                      00003 ; Das Blinkenlichten: 10F 1-Wire RGB Receiver + Indicator
                      00004 
                      00005 ; This software and protocol (source and binaries) are free for non-commercial use. The software may be 
                            freely redistributed
                      00006 ; either in modified or unmodified forms. In all cases the source code and this license text must be inc
                            luded.
                      00007 
                      00008 
                      00009 ; Config bits: WDT ON, MCLR as GP3, CodeProtect OFF.
                      00010 
                      00011 
                      00012 ; ----------------------
                      00013 
                      00014 #define         MYADDR          0x01            ; Personalized address to be stored in THIS chip. Each c
                            hip on the bus
                      00015                                                                         ; must have a unique address to 
                            be controlled independently...
                      00016 
                      00017 #define         COMM_ANODE      0x01            ; If indicator is common-anode, polarity of output drive
                             and idle are inverted
                      00018 
                      00019 ; ----------------------
                      00020 
                      00021 ; Base contents of the OPTION register. OPTION is write-only, so can't do read-modify-write in code. We'
                            ll be needing to set/clear individual bits and don't want to hardcode this multiple places.
                      00022 #define         OPTION_VALUES   B'11001000'     ; wakeup-on-change DISabled, pullups DISabled, timer0 cl
                            k internal, source edge low-to-high (don't care), prescaler assigned to WDT, /1
                      00023 
                      00024         list    p=10f200
                      00025         #include "p10f200.inc"
                      00001         LIST
                      00002 ; P10F200.INC  Standard Header File, Version 1.02    Microchip Technology, Inc.
                      00125         LIST
                      00026 
                      00027 
                      00028 
0000                  00029         org 0x00                        ; effective reset vector
0000   0A0D           00030         goto    start
                      00031 
                      00032         ; First 64 bytes and last byte (osc. calibration word) are readable regardless of CodeProtect bi
                            ts, so
                      00033         ; put the revision there so we always have it, even if these bits get set.
                      00034 
                      00035 ; NOTES: This eats almost 1/4 of the code space; remove or shorten if things get tight.
                      00036 ; 'DT' stores in a (1 byte -> 1 word) readable format; probably decodes as RETLW xx
                      00037 ;       DT      "$Id: main.asm,v 1.7 2008/02/18 20:26:26 tgipson Exp $"
                      00038 ; Damn, ate up a bunch of ROM with the >v1 cmds. Just gonna set it by hand in very short form...
0001                  00039 str_version:
0001   0876 0831 082E 00040         DT "v1.1 tgipson"
       0831 0820 0874 
       0867 0869 0870 
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

       0873 086F 086E 
                      00041 
                      00042 ;       org     D'64'
000D                  00043 start:
000D   0EFE           00044         andlw   B'11111110'
000E   0025           00045         movwf   OSCCAL          ; Use factory OSCCAL value from last ROM byte; GP2 on GP2
                      00046 ;       movlw   B'01111110'
                      00047 ;       movwf   OSCCAL          ; disregard calibration and set osc. speed to maximum; GP2 on GP2
                      00048 
000F   0CC8           00049         movlw   OPTION_VALUES   ; see define above
0010   0002           00050         OPTION                          ; store into OPTION reg.
                      00051 
                      00052         ; Determine how we woke up... WDT can't be shut off in code, so powersave mode is exited by bus 
                            activity OR WDT reset.
                      00053 ;       btfsc   STATUS, GPWUF   ; Wakeup on pin change bit set?
0011   0663           00054         btfsc   STATUS, 3               ; Was power down mode set? PD\ cleared = powerdown mode
0012   0A16           00055         goto    init                    ; if we weren't poweredowned: always reset
0013   0783           00056         btfss   STATUS, 4               ; if WDT timed out - just go back to sleep (TO\ cleared = timeou
                            t)
0014   0AB4           00057         goto    poke_reg_0_power_save; if TO\ low
0015   0A35           00058         goto    awaken                  ; else - just re-awakening from powersave, do not clear memory c
                            ontents
                      00059 
                      00060 
                      00061 
                      00062 
                      00063 
0016                  00064 init:
0016   0004           00065         clrwdt                          ; Can't do this earlier; it resets power-up state bits
0017   0C00           00066         movlw   B'00000000'     ; set all pins as output which can be
0018   0006           00067         TRIS    GPIO            ; ...
                      00068 ;       clrf    GPIO
                      00069 
                      00070 ;       bsf             GPIO, GREEN             ; briefly show startup value to show running or reset...
                      00071 ;       bcf             GPIO, BLUE
                      00072 ;       bsf             GPIO, RED
                      00073 
0019   0C0E           00074         movlw   B'00001110'             ; show blue in common-anode; yellow in common-cathode
001A   0026           00075         movwf   GPIO
                      00076 
                      00077 
001B   0075           00078         clrf    GROUPADDR               ; initial Group 0x00 (none / same as broadcast address)
001C   0079           00079         clrf    DEF_VALID               ; No deferred update buffers contain valid data
                      00080 
001D   0040           00081         clrw                                    ; Initially clear PWM intensities
                      00082         #if (COMM_ANODE == 1)   ; ...
001E   0CFF           00083         movlw   B'11111111'             ; for common-anode, '1' (voltage) on the port extinguishes the L
                            ED.
                      00084         #endif                                  ; ...
001F   0032           00085         movwf   PWM_R                   ;
0020   0033           00086         movwf   PWM_G                   ;
0021   0034           00087         movwf   PWM_B                   ;
0022   0036           00088         movwf   DEF_R
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0023   0037           00089         movwf   DEF_G
0024   0038           00090         movwf   DEF_B
                      00091 
0025                  00092 debug_hang:             ; show long blue to indicate startup and/or sync lost. Change according to how l
                            ong you want to hang of course...
0025   0C80           00093         movlw   0x80
0026   0031           00094         movwf   COUNT
0027   0070           00095         clrf    SCRATCH0
0028                  00096 debug_hang_outer:
0028   0004           00097         clrwdt
0029   02F0           00098         decfsz  SCRATCH0, f
002A   0A28           00099         goto    debug_hang_outer
002B   02F1           00100         decfsz  COUNT, f
002C   0A28           00101         goto    debug_hang_outer
                      00102 
                      00103 
002D                  00104 reset_sync:                                     ; Sync with extended STOP condition (bus idle)
002D   0666           00105         btfsc   GPIO, SDI               ; SDI low?
002E   0A2D           00106         goto    reset_sync              ; if no
                      00107 
002F   0004           00108         clrwdt
0030   0061           00109         clrf    TMR0                    ; begin timing stop condition
0031                  00110 reset_sync_wait1:
0031   0666           00111         btfsc   GPIO, SDI               ; line still low?
0032   0A2D           00112         goto    reset_sync              ; if no
0033   06E1           00113         btfsc   TMR0, 7                 ; timer rollxxxer?
0034   0A31           00114         goto    reset_sync_wait1; if no
                      00115 
                      00116                                                         ; else - fall through and begin running...
0035                  00117 awaken:
                      00118 ;       bcf             STATUS, GPWUF   ; Clear wakeup-from-pin-change status, if any ; No longer used -
                             testing PD bit instead
                      00119 
0035                  00120 main:                                           ; Where it all happens; check for START condition and (i
                            f none) advance one color's PWM.
0035   0004           00121         clrwdt                                  ; WDT time-out will reset the chip if this loop is not r
                            eturned to in a timely manner (1-wire framing error, e.g. waiting for a serial bit that never co
0036   0666           00122         btfsc   GPIO, SDI               ; start bit?
0037   0A40           00123         goto    getcmd                  ; fake 'call' - shallow stack
0038   09E7           00124         call    pwm_r
0039   0666           00125         btfsc   GPIO, SDI               ; start bit?
003A   0A40           00126         goto    getcmd                  ; fake 'call' - shallow stack
003B   09EF           00127         call    pwm_g
003C   0666           00128         btfsc   GPIO, SDI               ; start bit?
003D   0A40           00129         goto    getcmd                  ; fake 'call' - shallow stack
003E   09F7           00130         call    pwm_b
003F   0A35           00131         goto    main
                      00132 
                      00133 
                      00134 ; +17 processcmd
                      00135 ; 
                      00136 
                      00137 ; ---------------------------------------------------
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00138 ; Check for incoming cmd byte on SDI. If cmd (start condition), receive the cmd packet to CMDBUF.
                      00139 ; ASSUMPTION: Start condition is long enough that the longest possible complete loop will still get us b
                            ack here in time to catch it.
                      00140 
0040                  00141 getcmd:
0040   0C1A           00142         movlw   CMDBUF                  ; init buffer ptr
0041   0024           00143         movwf   FSR                             ;
                      00144 
0042                  00145 getstartbit:
0042   0666           00146         btfsc   GPIO, SDI               ; spinlock until start condition released
0043   0A42           00147         goto    getstartbit             ; ...
                      00148 
0044                  00149 getbyte1:
0044   0061           00150         clrf    TMR0                            ; begin timing low half of bit
0045   0C08           00151         movlw   H'08'                           ; going to shift in this many bits
0046   0031           00152         movwf   COUNT                           ;
                      00153 
0047                  00154 getbit_firsthalf:
0047   09DD           00155         call    pwmjump                                 ; ONCE, in dead time. Helps reduce flicker durin
                            g saturated bus condition, at the expense of max. bus speed... 18 clocks including call/return
0048                  00156 getbit_firsthalf_end:
0048   0766           00157         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
0049   0A48           00158         goto    getbit_firsthalf_end; if no
                      00159 
004A   0261           00160         comf    TMR0, f                         ; if yes - begin timing high half of bit
                      00161 
004B                  00162 getbit_secondhalf:
004B   0666           00163         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
004C   0A4B           00164         goto    getbit_secondhalf       ; if no
                      00165 
004D   0201           00166         movf    TMR0, w                         ; get timer's value
004E   0030           00167         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
004F   0061           00168         clrf    TMR0                            ; begin timing low half of bit. We know it's longer than
                             a few clocks, plenty of time to...
0050   0370           00169         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
0051   0360           00170         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00171 
0052   02F1           00172         decfsz  COUNT,f                         ; got all bits?
0053   0A47           00173         goto    getbit_firsthalf        ; if no - wait for next
                      00174                                                                 ; else - fall through and begin 2nd byte
                             of cmd...
                      00175 
0054   0061           00176         clrf    TMR0                            ; begin timing low half of bit
0055   02A4           00177         incf    FSR,f                           ; point to 2nd buffer byte
                      00178 
0056                  00179 getbyte2:
0056   0C08           00180         movlw   H'08'                           ; going to shift in this many bits
0057   0031           00181         movwf   COUNT                           ;
                      00182 
0058                  00183 getbit_firsthalf2:
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0058   09DD           00184         call    pwmjump                                 ; ONCE, in dead time.  18 clocks including call/
                            return
0059                  00185 getbit_firsthalf_end2:
0059   0766           00186         btfss   GPIO, SDI                       ; wait for SDI to go high - has it?
005A   0A59           00187         goto    getbit_firsthalf_end2; if no
                      00188 
005B   0261           00189         comf    TMR0, f                         ; if yes - begin timing high half of bit
                      00190 
005C                  00191 getbit_secondhalf2:
005C   0666           00192         btfsc   GPIO, SDI                       ; now waiting for bit to go low again - has it?
005D   0A5C           00193         goto    getbit_secondhalf2      ; if no
                      00194 
005E   0201           00195         movf    TMR0, w                         ; get timer's value
005F   0030           00196         movwf   SCRATCH0                        ; .. to scratch reg (ghetto chip doesn't allow operation
                             on WREG..?)
0060   0061           00197         clrf    TMR0                            ; begin timing low half of bit
0061   0370           00198         rlf             SCRATCH0,f                      ; rotate MSB of stored TMR0 into 'C'arry (don't 
                            care about other bits)
0062   0360           00199         rlf             INDF,f                          ; shift bit in 'C'arry into currently-addressed 
                            buffer position
                      00200 
0063   02F1           00201         decfsz  COUNT,f                         ; got all bits?
0064   0A58           00202         goto    getbit_firsthalf2       ; if no - wait for next
                      00203 
                      00204         ; 66 clocks from here to main (18+48)
                      00205 
                      00206         ; check address to see if it's anything we respond to...
                      00207 
0065   00E4           00208         decf    FSR, f                  ; point back to 1st byte of received cmd (the address)
                      00209 
0066   0C00           00210         movlw   H'00'                   ; General Call addr? (everybody! everybody!)
0067   0180           00211         xorwf   INDF, w                 ;
0068   0643           00212         btfsc   STATUS, Z               ;
0069   0A73           00213         goto    processcmd              ; if yes
                      00214                                                         ; else
                      00215 
006A   0C01           00216         movlw   MYADDR                  ; This chip's addr? (NOTE: Hard-coded literal from above)
006B   0180           00217         xorwf   INDF, W                 ;
006C   0643           00218         btfsc   STATUS, Z               ;
006D   0A73           00219         goto    processcmd              ; if yes
                      00220                                                         ; else
                      00221 
006E   0215           00222         movf    GROUPADDR, w    ; This chip's Group addr? (NOTE: RAM variable)
006F   0180           00223         xorwf   INDF, W                 ;
0070   0643           00224         btfsc   STATUS, Z               ;
0071   0A73           00225         goto    processcmd              ; if yes
                      00226 
0072   0A35           00227         goto    main                    ; else - not for us...
                      00228 
0073                  00229 processcmd:     ; 48 incl. call/return
                      00230 
0073   0C1B           00231         movlw   CMDBUF+1                ; point to 2nd byte of CMDBUF (cmd)
0074   0024           00232         movwf   FSR                             ; ...
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00233 
0075   06E0           00234         btfsc   INDF, 7                 ; Extended Command bit?
0076   0A7E           00235         goto    extcmd                  ; if yes
                      00236                                                         ; else
                      00237 
0077   06C0           00238         btfsc   INDF, 6                 ; R cmd
0078   09BE           00239         call    processcmd_r    ; 13
0079   06A0           00240         btfsc   INDF, 5                 ; G cmd
007A   09C2           00241         call    processcmd_g
007B   0680           00242         btfsc   INDF, 4                 ; B cmd
007C   09C6           00243         call    processcmd_b
007D   0A35           00244         goto    main                    ; done
                      00245 
                      00246 
                      00247 
                      00248 ; If payload byte was '1xxxxxxx', decode as an Extended command...
                      00249 ; 11xxxxxx Set Group Address
                      00250 ; 10XXxxxx Poke virtual reg XX with value xxxx, where...
                      00251 ; VAddr 00: Flags [x    identify        activate_deferred       power_save]
                      00252 ; VAddr 01: Defer buf R
                      00253 ; VAddr 02: Defer buf G
                      00254 ; VAddr 03: Defer buf B
                      00255 
007E                  00256 extcmd:
                      00257 
                      00258 
007E   06C0           00259         btfsc   INDF, 6                 ; Decode against "Set Group"
007F   0A84           00260         goto    setgroup                ; if Set Group bit set
                      00261                                                         ; else...
0080   06A0           00262         btfsc   INDF, 5                 ; Poke reg is 2 or 3?
0081   0A88           00263         goto    poke_reg_2_3    ; if yes
0082   0A94           00264         goto    poke_reg_0_1    ; else - must be 0 or 1
0083   0A35           00265         goto    main
                      00266 
                      00267 
0084                  00268 setgroup:
0084   0200           00269         movf    INDF, w
0085   0E3F           00270         andlw   B'00111111'             ; Max. group addr 0x40 because 2 bits were taken up by extcmd
0086   0035           00271         movwf   GROUPADDR               ; store remaining bits as group address
0087   0A35           00272         goto    main                    ; done
                      00273 
0088                  00274 poke_reg_2_3:   ; Handle poke regs 2,3
0088   0680           00275         btfsc   INDF,4                  ; poke reg is 3?
0089   0A8F           00276         goto    poke_reg_3              ; if yes
                      00277                                                         ; else...
008A                  00278 poke_reg_2:                                     ; Setting Green deferred update
008A   0200           00279         movf INDF, w
008B   0E0F           00280         andlw   B'00001111'             ; only valid values
008C   0037           00281         movwf   DEF_G                   ;
008D   0539           00282         bsf             DEF_VALID, GREEN; and mark it as having a valid update
008E   0A35           00283         goto    main
                      00284 
008F                  00285 poke_reg_3:                                     ; Setting Blue deferred update
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

008F   0200           00286         movf INDF, w
0090   0E0F           00287         andlw   B'00001111'             ; only valid values
0091   0038           00288         movwf   DEF_B                   ;
0092   0559           00289         bsf             DEF_VALID, BLUE ; and mark it as having a valid update
0093   0A35           00290         goto    main
                      00291 
0094                  00292 poke_reg_0_1                            ; Handle poke regs 0,1
0094   0680           00293         btfsc   INDF, 4                 ; poke reg is 1?
0095   0AB9           00294         goto    poke_reg_1              ; if yes
                      00295                                                         ; else...
0096                  00296 poke_reg_0:                                     ; Handling Flag bits
                      00297                                                         ; Remember each of these virtual regs is only 4 
                            bits long because that's how many were left in the CMD byte to specify its value...
                      00298         ; Reg 0 bit 3 is currently unused, so skipping it...
                      00299 
0096   0640           00300         btfsc   INDF, 2                 ; Identify?
0097   0A9C           00301         goto    poke_reg_0_identify; if yes
                      00302                                                         ; else...
0098   0620           00303         btfsc   INDF, 1                 ; Activate deferred updates?
0099   0AA8           00304         goto    poke_reg_0_activate_def; if yes
                      00305 
                      00306                                                         ; Power Save will be the last command we check f
                            or, since if one of those is coming down the pipe we shouldn't be getting further commands for a
009A   0700           00307         btfss   INDF, 0                 ; Power Save bit?
009B   0A35           00308         goto    main                    ; if no - that's all of them!
                      00309 
                      00310 
009C                  00311 poke_reg_0_identify:
                      00312         ; FIXME: Writeme
009C   0CC8           00313         movlw   OPTION_VALUES   ; get initial OPTION contents (hardcoded)
009D   0EBF           00314         andlw   B'10111111'             ; enable weak pullups (GP3/SDI) by clearing bit 6
009E   0002           00315         OPTION  
009F   0070           00316         clrf    SCRATCH0
00A0                  00317 identify_timer: ; count to a bunch...
00A0   0004           00318         clrwdt
00A1   02F0           00319         decfsz  SCRATCH0,f              ; done counting?
00A2   0AA0           00320         goto    identify_timer  ; if no
                      00321                                                         ; else...
00A3   0CC8           00322         movlw   OPTION_VALUES   ; re-get initial contents
00A4   0002           00323         OPTION                                  ; set everything back to normal
00A5                  00324 identify_wait:                          ; Wait until freshly dropped line returns to '0' state. Could be
                             slow to drop with large pulldown
00A5   0666           00325         btfsc   GPIO, SDI               ; or with some other device still holding it up.
00A6   0AA5           00326         goto    identify_wait   ; if line still high
00A7   0A35           00327         goto    main                    ; else
                      00328 
00A8                  00329 poke_reg_0_activate_def:        ; A longer command than most to accomplish; might want to delay followin
                            g cmds a few ms...
00A8   0C16           00330         movlw   DEF_R                   ; point INDF to *address* of DEF_R
00A9   0024           00331         movwf   FSR
00AA   0619           00332         btfsc   DEF_VALID, RED
00AB   09BE           00333         call    processcmd_r
00AC   02A4           00334         incf    FSR, f                  ; pointing to DEF_G
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00AD   0639           00335         btfsc   DEF_VALID, GREEN
00AE   09C2           00336         call    processcmd_g
00AF   02A4           00337         incf    FSR, f                  ; pointing to DEF_B
00B0   0659           00338         btfsc   DEF_VALID, BLUE
00B1   09C6           00339         call    processcmd_b
00B2   0079           00340         clrf    DEF_VALID               ; activated all; updates are no longer new
00B3   0A35           00341         goto    main                    ; done! FIXME: Count the clocks on this...
                      00342 
00B4                  00343 poke_reg_0_power_save:          ; For best results, this should be sent on addr 0 following globally set
                            ting all intensities to 0. Otherwise you aren't saving much power, and the next cmd will wake ev
00B4   0CC8           00344         movlw   OPTION_VALUES   ; get initial OPTION contents (hardcoded)
00B5   0E7F           00345         andlw   B'01111111'             ; enable Wakeup on Change by clearing bit 7
00B6   0002           00346         OPTION                                  ; write new contents
00B7   0206           00347         movf    GPIO, w                 ; dummy read of I/O port to set clear any existing 'changes'
00B8   0003           00348         sleep                                   ; sleep...
                      00349 ;       goto    main                    ; should never be reached; PIC10s reset on wakeup
                      00350 
                      00351 
00B9                  00352 poke_reg_1:                                     ; Setting Red deferred update
00B9   0200           00353         movf INDF, w
00BA   0E0F           00354         andlw   B'00001111'             ; only valid values
00BB   0036           00355         movwf   DEF_R                   ;
00BC   0519           00356         bsf             DEF_VALID, RED  ; and mark it as having a valid update
00BD   0A35           00357         goto    main
                      00358 
                      00359 ; ---------------------------------------------------
                      00360 ; Process command byte in buffer for the given color
                      00361 
00BE                  00362 processcmd_r:
00BE   09CA           00363         call    setpwm                          ; 7
                      00364         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00BF   0FFF           00365         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00366         #endif
00C0   0032           00367         movwf   PWM_R
00C1   0800           00368         retlw   0
00C2                  00369 processcmd_g:
00C2   09CA           00370         call    setpwm
                      00371         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00C3   0FFF           00372         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00373         #endif
00C4   0033           00374         movwf   PWM_G
00C5   0800           00375         retlw   0
00C6                  00376 processcmd_b:
00C6   09CA           00377         call    setpwm
                      00378         #if (COMM_ANODE == 1)           ; Switched in for common-anode drive
00C7   0FFF           00379         xorlw   B'11111111'                     ; complement WREG directly (comm. anode: line LOW means 
                            LED is lit)
                      00380         #endif
00C8   0034           00381         movwf   PWM_B
00C9   0800           00382         retlw   0
                      00383 
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00384 
                      00385 ; ---------------------------------------------------
                      00386 ; Given low 4 bits of cmd in INDF, return that many '1's in WREG.
                      00387 ;
                      00388 ; Want to return a value containing the number of '1's specified in the intensity
                      00389 ; value. But want to spread them out for faster switching and less perceivable flicker.
00CA                  00390 setpwm:
00CA   0200           00391         movf    INDF, w         ; cmd value
00CB   0E0F           00392         andlw   B'00001111'     ; mask off bogus bits
00CC   01E2           00393         addwf   PCL, f          ; skip that many instructions
00CD   0800           00394         retlw   B'00000000' ; 0x00
00CE   0801           00395         retlw   B'00000001' ; 0x01
00CF   0811           00396         retlw   B'00010001' ; 0x02
00D0   0849           00397         retlw   B'01001001' ; 0x03
00D1   0855           00398         retlw   B'01010101' ; 0x04
00D2   0857           00399         retlw   B'01010111' ; 0x05
00D3   0877           00400         retlw   B'01110111' ; 0x06
00D4   087F           00401         retlw   B'01111111' ; 0x07
00D5   08FF           00402         retlw   B'11111111' ; 0x08      ; last valid value
00D6   08FF           00403         retlw   B'11111111' ; 0x09      ; Should not be sent any values this high; we can't represent th
                            em in the PWM registers anyway
00D7   08FF           00404         retlw   B'11111111' ; 0x0A
00D8   08FF           00405         retlw   B'11111111' ; 0x0B
00D9   08FF           00406         retlw   B'11111111' ; 0x0C
00DA   08FF           00407         retlw   B'11111111' ; 0x0D
00DB   08FF           00408         retlw   B'11111111' ; 0x0E
00DC   08FF           00409         retlw   B'11111111' ; 0x0F
                      00410 ;       retlw   0x00            ; pure paranoia
                      00411 
                      00412 ; ---------------------------------------------------
                      00413 ; Perform one iteration/rotation of "poor man's PWM" for each color's register
                      00414 
                      00415 ; 'pwmjump' tries to evenly distribute PWM advances during bit receives by the value of the COUNT regist
                            er 
                      00416 ; (used during 1-wire receive to tell how many bits remaining). Well, we have 8 bits and 3 colors, so re
                            d will
                      00417 ; cycle a little slower than the rest during 1-wire receives, if anyone cares ;)
                      00418 
                      00419                                                         ; ---------------
                      00420         #if COMM_ANODE==0               ; Switched in for common-cathode drive
                      00421 pwmjump:
                      00422         movf    COUNT, w
                      00423         addwf   PCL, f
                      00424         goto    pwm_g   ; 0x00
                      00425         goto    pwm_b   ; 0x01
                      00426         goto    pwm_r   ; 0x02
                      00427         goto    pwm_g   ; 0x03
                      00428         goto    pwm_b   ; 0x04
                      00429         goto    pwm_r   ; 0x05
                      00430         goto    pwm_g   ; 0x06
                      00431         goto    pwm_b   ; 0x07
                      00432 
                      00433 pwm:
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00434 pwm_r:
                      00435         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
                      00436         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
                      00437         btfsc   STATUS, C               ; catch the bit that just fell off the left
                      00438         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00439 
                      00440         bcf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
                      00441         btfsc   STATUS, C               ; comm. cathode: '1' = 'on'. Want to err on the side of not quit
                            e 100% duty cycle vs. dimly glowing when 'off'.
                      00442         bsf             GPIO, RED               ; .
                      00443         retlw   0
                      00444 pwm_g:
                      00445         rlf             PWM_G,f
                      00446         bcf             PWM_G, 0
                      00447         btfsc   STATUS, C
                      00448         bsf             PWM_G, 0
                      00449 
                      00450         bcf             GPIO, GREEN
                      00451         btfsc   STATUS, C
                      00452         bsf             GPIO, GREEN
                      00453         retlw   0
                      00454 pwm_b:
                      00455         rlf             PWM_B,f
                      00456         bcf             PWM_B, 0
                      00457         btfsc   STATUS, C
                      00458         bsf             PWM_B, 0
                      00459 
                      00460         bcf             GPIO, BLUE
                      00461         btfsc   STATUS, C
                      00462         bsf             GPIO, BLUE
                      00463         retlw   0
                      00464 
                      00465 
                      00466         #endif
                      00467                                                         ; ---------------------
                      00468         #if COMM_ANODE == 1             ; Switched in for common-anode drive
                      00469 
00DD                  00470 pwmjump:
00DD   0211           00471         movf    COUNT, w
00DE   01E2           00472         addwf   PCL, f
00DF   0AEF           00473         goto    pwm_g   ; 0x00
00E0   0AF7           00474         goto    pwm_b   ; 0x01
00E1   0AE7           00475         goto    pwm_r   ; 0x02
00E2   0AEF           00476         goto    pwm_g   ; 0x03
00E3   0AF7           00477         goto    pwm_b   ; 0x04
00E4   0AE7           00478         goto    pwm_r   ; 0x05
00E5   0AEF           00479         goto    pwm_g   ; 0x06
00E6   0AF7           00480         goto    pwm_b   ; 0x07
                      00481 
00E7                  00482 pwm:
00E7                  00483 pwm_r:
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE 11


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00E7   0372           00484         rlf             PWM_R,f                 ; Rotate next PWM value into 'C'arry
00E8   0412           00485         bcf             PWM_R, 0                ; This is whatever random junk used to be in there, so c
                            lear it...
00E9   0603           00486         btfsc   STATUS, C               ; catch the bit that just fell off the left
00EA   0512           00487         bsf             PWM_R, 0                ; and stuff it back on the right.
                      00488 
00EB   0506           00489         bsf             GPIO, RED               ; Now set the port line according to the same 'C'arry co
                            ntents.
00EC   0703           00490         btfss   STATUS, C               ; ... Remember kids, comm. anode means '1' = 'off'.
00ED   0406           00491         bcf             GPIO, RED               ; .
00EE   0800           00492         retlw   0
00EF                  00493 pwm_g:
00EF   0373           00494         rlf             PWM_G,f
00F0   0413           00495         bcf             PWM_G, 0
00F1   0603           00496         btfsc   STATUS, C
00F2   0513           00497         bsf             PWM_G, 0
                      00498 
00F3   0526           00499         bsf             GPIO, GREEN
00F4   0703           00500         btfss   STATUS, C
00F5   0426           00501         bcf             GPIO, GREEN
00F6   0800           00502         retlw   0
00F7                  00503 pwm_b:
00F7   0374           00504         rlf             PWM_B,f
00F8   0414           00505         bcf             PWM_B, 0
00F9   0603           00506         btfsc   STATUS, C
00FA   0514           00507         bsf             PWM_B, 0
                      00508 
00FB   0546           00509         bsf             GPIO, BLUE
00FC   0703           00510         btfss   STATUS, C
00FD   0446           00511         bcf             GPIO, BLUE
00FE   0800           00512         retlw   0
                      00513         #endif
                      00514 
                      00515 
                      00516 ; -------------------
                      00517 
                      00518 
                      00519 ; Command packet format: <start> <addr[7..0]><cmd[7..0]><stop>
                      00520 ;________________________-------......16 data bits......______
                      00521 
                      00522 ; The bus idles low.
                      00523 
                      00524 ; Start condition: Bus goes HIGH and lasts for longer than the longest possible loop run, so that all de
                            vices are guaranteed to catch it.
                      00525 ; Data bits consist of a low period (low half) followed by a high period (high half). A 0 is denoted by 
                            making the LOW half longer than the HIGH half,
                      00526 ;   and a 1 by making the HIGH half longer. Ideally, all bits should total the same length, but since th
                            e low half sets the baud rate on a bit-per-bit basis,
                      00527 ;   this is not required. However, the low half should be a minimum 18 device clocks (18/1MHz=18uS) for 
                            most accurate timing, 
                      00528 ;   and should not exceed 255 device clocks (255uS).
                      00529 
                      00530 
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE 12


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00531 ; Cmd BYTE format: ERGBIIII
                      00532 ; RGB: Which color(s) cmd applies to
                      00533 ; IIII: Set intensity (0 ~ 8)
                      00534 ; E: Extended Command flag. If '1', decode remaining bits as Extended Cmd as described below...
                      00535 
                      00536 ; --- Extended Commands ---
                      00537 ; 11xxxxxx : Set Group Addr to value xxxx
                      00538 ; 10XXxxxx : Poke "Virtual reg" XX with contents xxxx (see below), where XX is the address of a virtual 
                            4-bit reg and xxxx is the value to poke.
                      00539 
                      00540 
                      00541 ; Vreg 00: Flags [x     identify        activate_deferred       power_save]
                      00542 ; Vreg 01: Defer buf R
                      00543 ; Vreg 02: Defer buf G
                      00544 ; Vreg 03: Defer buf B
                      00545 
                      00546 ; Detailed description of the virtual registers:
                      00547 
                      00548 ; Vreg 01 ~ 03 allow a deferred update to be sent for the R, G and B channel respectively. The new inten
                            sity value(s) are stored in the 
                      00549 ; appropriate register(s), but the old intensity values continue to be displayed until an activate_defer
                            red command is executed, at which point
                      00550 ; the new intensities are displayed. This will be particularly useful for trickling new values over the 
                            bus, then sending a single activate_deferred
                      00551 ; to all devices (addr 0) to give the appearance of a simultaneous update.
                      00552 
                      00553 ; Vreg 00 is a virtual register among virtual register. Rather than writing a value to it, you write to 
                            it setting an individual bit to
                      00554 ; performs the requested action. Once the action is performed, the bit can be considered automatically c
                            leared.
                      00555 ;       * Unused (bit 3): Doesn't do anything.
                      00556 ;       * Identify (bit 2): On receipt of this cmd by a given device address, this device shall pull the
                             data line HIGH (internal weak pull-up)
                      00557 ;               for a period of about 512 device clocks (or whatever, plenty long enough for master devi
                            ce to see it). Normal operation is then resumed.
                      00558 ;               Note that this may disrupt other devices on the bus, who interpret the pullup signal as 
                            a new START command. If this is bothersome an
                      00559 ;               Identify command may be followed by a startless dummy command if a device responds.
                      00560 ;       * Activate_deferred: Replaces the currently displayed intensities with the contents of the Defer
                             (R,G,B) regs if they contain a valid update.
                      00561 ;       * Power_save: This command is currently unsupported; do not use.
                      00562 
                      00563 ; This command will stop the CPU and any pulse modulation activities and enter a low-power SLEEP mode. T
                            he device will remain in 
                      00564 ;               SLEEP mode until the next bus activity occurs, at which point it will re-awaken.
                      00565 
                      00566 
                      00567 ; Ok, so the protocol as shown leaves only 1 bit unused.
                      00568 ; Definitely painting ourselves into a corner, but might be able to squeak out a little more functionali
                            ty by making that topmost flags bit
                      00569 ; a 'Use Indirection' flag that changes one of the existing VADDRs to a pointer to a numbered register, 
                            or even to a full register bank.
                      00570 ; This then gives 16 possible registers for each VADDR, but packing any further functionalities onto PIC
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE 13


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            10F200 would be challenging at best.
                      00571 ; Therefore, I think the above protocol definition is OK as-is, and any bigger chip will use a more robu
                            st 2-wire (clk,data) serial and its own protocol.
                      00572 
                      00573 
                      00574 #include "vars.inc"             ; Memory map
                      00001 ; $Id: vars.inc,v 1.2 2008/02/18 20:26:26 tgipson Exp $
                      00002 ; Memory register definitions for Blinkenlichten
                      00003 
                      00004 
                      00005         cblock  0x10
                      00006 
  00000010            00007         SCRATCH0        ; general purpose scratch register
  00000011            00008         COUNT           ; bits-in-byte countdown
                      00009 
  00000012            00010         PWM_R           ; poor-man's PWM registers: '1' bits will be rotated around in them
  00000013            00011         PWM_G           ;
  00000014            00012         PWM_B           ;
                      00013 
  00000015            00014         GROUPADDR       ; Storage byte for Group Address
                      00015 
  00000016            00016         DEF_R           ; Deferred Update regs
  00000017            00017         DEF_G           ;
  00000018            00018         DEF_B           ;
  00000019            00019         DEF_VALID       ; xxxxxRGB Flags indicate whether DEFx bufs contain valid update data
                      00020 
  0000001A            00021         CMDBUF          ; buffer start - must be at end of vars
  0000001B            00022         CMDBUF2         ; 2nd byte of cmd
                      00023         endc
                      00575 #include "defs.inc"             ; Port and bit definitions
                      00001 ; $Id: defs.inc,v 1.2 2008/02/18 20:26:26 tgipson Exp $
                      00002 ; Port and bit definitions for Blinkenlichten
                      00003 
  00000003            00004 SDI             equ     3
  00000000            00005 RED             equ     0
  00000001            00006 GREEN   equ     1
  00000002            00007 BLUE    equ     2
                      00576 
                      00577         end
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE 14


SYMBOL TABLE
  LABEL                             VALUE 

BLUE                              00000002
C                                 00000000
CAL0                              00000001
CAL1                              00000002
CAL2                              00000003
CAL3                              00000004
CAL4                              00000005
CAL5                              00000006
CAL6                              00000007
CMDBUF                            0000001A
CMDBUF2                           0000001B
COMM_ANODE                        0x01
COUNT                             00000011
DC                                00000001
DEF_B                             00000018
DEF_G                             00000017
DEF_R                             00000016
DEF_VALID                         00000019
F                                 00000001
FOSC4                             00000000
FSR                               00000004
GP0                               00000000
GP1                               00000001
GP2                               00000002
GP3                               00000003
GPIO                              00000006
GPWUF                             00000007
GREEN                             00000001
GROUPADDR                         00000015
INDF                              00000000
MYADDR                            0x01
NOT_GPPU                          00000006
NOT_GPWU                          00000007
NOT_PD                            00000003
NOT_TO                            00000004
OPTION_VALUES                     B'11001000'
OSCCAL                            00000005
PCL                               00000002
PS0                               00000000
PS1                               00000001
PS2                               00000002
PSA                               00000003
PWM_B                             00000014
PWM_G                             00000013
PWM_R                             00000012
RED                               00000000
SCRATCH0                          00000010
SDI                               00000003
STATUS                            00000003
T0CS                              00000005
T0SE                              00000004
TMR0                              00000001
W                                 00000000
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE 15


SYMBOL TABLE
  LABEL                             VALUE 

Z                                 00000002
_CP_OFF                           00000FFF
_CP_ON                            00000FF7
_IntRC_OSC                        00000FFF
_MCLRE_OFF                        00000FEF
_MCLRE_ON                         00000FFF
_WDT_OFF                          00000FFB
_WDT_ON                           00000FFF
__10F200                          00000001
awaken                            00000035
debug_hang                        00000025
debug_hang_outer                  00000028
extcmd                            0000007E
getbit_firsthalf                  00000047
getbit_firsthalf2                 00000058
getbit_firsthalf_end              00000048
getbit_firsthalf_end2             00000059
getbit_secondhalf                 0000004B
getbit_secondhalf2                0000005C
getbyte1                          00000044
getbyte2                          00000056
getcmd                            00000040
getstartbit                       00000042
identify_timer                    000000A0
identify_wait                     000000A5
init                              00000016
main                              00000035
poke_reg_0                        00000096
poke_reg_0_1                      00000094
poke_reg_0_activate_def           000000A8
poke_reg_0_identify               0000009C
poke_reg_0_power_save             000000B4
poke_reg_1                        000000B9
poke_reg_2                        0000008A
poke_reg_2_3                      00000088
poke_reg_3                        0000008F
processcmd                        00000073
processcmd_b                      000000C6
processcmd_g                      000000C2
processcmd_r                      000000BE
pwm                               000000E7
pwm_b                             000000F7
pwm_g                             000000EF
pwm_r                             000000E7
pwmjump                           000000DD
reset_sync                        0000002D
reset_sync_wait1                  00000031
setgroup                          00000084
setpwm                            000000CA
start                             0000000D
str_version                       00000001
MPASM  5.14                          MAIN.ASM   2-19-2008  0:41:24         PAGE 16


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXX-

All other memory blocks unused.

Program Memory Words Used:   255
Program Memory Words Free:     1


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     0 reported,     0 suppressed

